<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <!-- font family -->
    <link href="https://fonts.cdnfonts.com/css/intel-clear" rel="stylesheet">
    <!-- boootstap file -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <!-- costom css file -->
    <link rel="stylesheet" href="/css/vivek.css">
    <link rel="stylesheet" href="/css/yatri.css">

    <!-- all.min file -->
    <link rel="stylesheet" href="/css/all.min.css">

</head>

<body>



    <main>

        <!-- header -->
        <header>
            <div id="navbar"></div>
        </header>

        <!-- poster -->
        <section class=" VK_light_blue">
            <div class="VK_cont">
                <div class="row m-0">
                    <div class="col text-white">
                        <h1 class="VK_py_pre_heading fw-light m-0 pt-3 pb-4">
                            Intel® Arc™ Graphics Developer Guide for Real-Time Ray Tracing in Games
                        </h1>
                    </div>
                </div>
            </div>
        </section>

        <section class="py-5">
            <div class="VK_cont">
                <div class="row m-0">
                    <div class="col-3">
                        <div class="VK_side_bar_postion_stickey bg-white">
                            <ul class="list-unstyled ps-3 ">
                                <li>
                                    <a href="" class="VK_a text-decoration-none d-inline-block px-2 py-1">
                                        Introduction
                                    </a>
                                </li>
                                <li>
                                    <a href="" class="VK_a text-decoration-none d-inline-block px-2 py-1">
                                        Real-Time Ray Tracing Functional Overview
                                    </a>
                                </li>
                                <li>
                                    <a href="" class="VK_a text-decoration-none d-inline-block px-2 py-1">
                                        Understanding the Thread Sorting Unit
                                    </a>
                                </li>
                                <li>
                                    <a href="" class="VK_a text-decoration-none d-inline-block px-2 py-1">
                                        Ray Tracing Intrinsic Implementation Details
                                    </a>
                                </li>
                                <li>
                                    <a href="" class="VK_a text-decoration-none d-inline-block px-2 py-1">
                                        Pipeline-Level Compiler Optimizations
                                    </a>
                                </li>
                                <li>
                                    <a href="" class="VK_a text-decoration-none d-inline-block px-2 py-1">
                                        Performance Guidelines for Developers
                                    </a>
                                </li>
                                <li>
                                    <a href="" class="VK_a text-decoration-none d-inline-block px-2 py-1">
                                        Acceleration Structure Guidelines
                                    </a>
                                </li>
                                <li>
                                    <a href="" class="VK_a text-decoration-none d-inline-block px-2 py-1">
                                        General Acceleration Structure Guidelines
                                    </a>
                                </li>
                                <li>
                                    <a href="" class="VK_a text-decoration-none d-inline-block px-2 py-1">
                                        General Shader Optimization Guidelines
                                    </a>
                                </li>
                                <li>
                                    <a href="" class="VK_a text-decoration-none d-inline-block px-2 py-1">
                                        DXR1.1 and RayQueries
                                    </a>
                                </li>
                                <li>
                                    <a href="" class="VK_a text-decoration-none d-inline-block px-2 py-1">
                                        Conclusion
                                    </a>
                                </li>
                                <li>
                                    <a href="" class="VK_a text-decoration-none d-inline-block px-2 py-1">
                                        Additional Resources
                                    </a>
                                </li>
                            </ul>
                        </div>
                        <div>
                            <p>
                                <b class="mb-2 d-inline-block">
                                    Joshua Barczak
                                </b>
                                <br>
                                Graphics Software Architect
                            </p>
                            <p>
                                <b class="mb-2 d-inline-block">
                                    Holger Gruen

                                </b>
                                <br>
                                Principal Graphics Engineer
                            </p>
                        </div>
                    </div>
                    <div class="col-8 ps-5">
                        <div class="">
                            <div class="VK_section_descriptions">
                                <div class="text-end">
                                    <p class="m-0 VK_print_email_font">
                                        <span class="VK_a mx-2 d-inline-block">
                                            <i class="fa-solid fa-print"></i>
                                        </span>
                                        <span class="VK_a mx-2 d-inline-block">
                                            <i class="fa-regular fa-envelope"></i>
                                        </span>
                                    </p>
                                </div>
                            </div>
                            <div class="mt-5">
                                <h5 class="">
                                    <a href="" class="Vk_text_underline_dots VK_a d-inline-block">
                                        Download the PDF
                                    </a>
                                </h5>
                                <p class="mt-5">
                                    The new Intel® Arc™ GPUs (formerly code named Alchemist) fully support the DirectX*
                                    12 Ultimate feature set including variable-rate shading (VRS), mesh shading and
                                    DirectX* Raytracing (DXR). Support for DXR and real-time ray tracing (RTRT) comes
                                    through new hardware acceleration blocks built into Intel® Arc™ GPUs. This developer
                                    guide describes RTRT applications and contains details developers need to fully
                                    incorporate this technology in their titles.
                                </p>
                                <p class="mt-5">
                                    This document is organized in two parts. The first part presents a functional
                                    description of Intel’s ray-tracing implementation, to provide developers with an
                                    accurate mental model. The second part provides a concrete, quotable list of
                                    guidelines for developers to maximize performance for RTRT applications.
                                </p>
                                <p>
                                    The following diagram illustrates the data and control flow in Intel’s ray-tracing
                                    implementation. The diagram shows an abstract view of the Xe-core, which is the
                                    scalability unit for the Xe-HPG GPU architecture, and dedicated accelerating
                                    hardware. Each Xe-core contains a number of Vector Engines (XVEs). These are Single
                                    Instruction Multiple Data (SIMD) compute units which execute ray-tracing shaders in
                                    groups of 8 or 16 shader threads. There is a dedicated hardware block attached to
                                    each Xe-core, the ray-tracing unit (RTU) which handles accelerated structure
                                    traversal, ray-triangle intersection, ray-box intersection, instance
                                    transformations, and hit-shader dispatch. The traversal and intersection hardware
                                    will operate on individual rays and will be multithreaded to facilitate latency
                                    hiding.
                                </p>
                            </div>
                            <section class="mt-5" id="VK_Real_time_Tracing_Overview">
                                <h3 class="VK_side_heading fw-light mb-3">
                                    Real-Time Ray Tracing Functional Overview
                                </h3>
                                <div>
                                    <img src="/img/vivek/VK_80.png" class="w-100" alt="">
                                </div>
                                <div class="my-3 py-4 px-3 VK_bg_e6">
                                    <p class="m-0">
                                        Figure 1. Data and control flow in Intel’s ray-tracing implementation
                                    </p>
                                </div>
                                <div class="mt-5">
                                    <p>
                                        In our implementation, the ray-tracing process is a synchronized flow between
                                        the ray-tracing shaders, which execute on the XVE, and scene traversal, which
                                        executes in the RTU. To initiate ray tracing, a ray-generation shader running on
                                        the XVE writes ray data to memory, and sends a SIMD TraceRay message to the RTU.
                                        The TraceRay message specifies one ray for each active SIMD lane. After sending
                                        the TraceRay message, the XVE thread will terminate, so that it is available for
                                        hit-shader execution, if necessary (refer to
                                        <a href="" class="Vk_text_underline_dots VK_a">
                                            Understanding Bucketed Thread Dispatch
                                        </a>
                                        for more details). Hit shaders are dispatched by the hardware, one ray at a
                                        time. The Thread Shorting Unit (TSU) is used to coalesce these individual rays
                                        into coherent SIMD groups. During this process the TSU hardware also sorts the
                                        rays by shader-record address in order to extract as much SIMD coherence as
                                        possible.
                                    </p>
                                    <p>
                                        Each ray-generation shader thread has an associated stack, which is a dedicated
                                        block of driver-allocated memory. The stack is used to store data across shader
                                        invocations, and for communication between the XVEs and the RTU (via the L1
                                        cache). The driver allocates a fixed set of stacks, and hardware allocates them
                                        to ray-generation threads as they are launched.
                                    </p>
                                    <p>
                                        During traversal, the entire state of a ray is maintained in dedicated registers
                                        within the RTU. Upon receipt of a traversal message, the hardware will read ray
                                        data from the ray’s stack, and initialize the traversal state registers. The
                                        state will be maintained in registers throughout traversal, until hardware
                                        determines that a shader must be run. At that point, the current state of the
                                        ray (object-space origin/direction, current instance, hit information) is
                                        written out to the ray stack, and its registers are re-allocated to service
                                        another incoming ray. The RTU is stateless, in that it does not continue to
                                        track rays once they have reached a shader execution point, and transitioned
                                        back to the XVE.
                                    </p>
                                    <p>
                                        For any-hit and intersection shaders, the ray’s internal traversal state is also
                                        written to memory, and the compiler will send a
                                        <b>
                                            TraceRay_Continue
                                        </b>
                                        message at the end of the shader to restart traversal. Upon receiving a
                                        <b>
                                            TraceRay_Continue
                                        </b>
                                        message, hardware will reload the traversal state from memory instead of
                                        initializing it, so that the earlier traversal is resumed where it left off.
                                    </p>
                                    <p>
                                        Note that all cross-stage communication is via cached memory. At launch time,
                                        each hit-shader thread receives a 16-bit stack ID, a shader-record pointer for
                                        fetching local arguments, and a global pointer for fetching global root
                                        arguments. All other data is read and written by XVEs and RTU hardware, as
                                        required. In our implementation, the minimum memory footprint for a single DXR
                                        ray is 256 bytes. This assumes no ray payload, no recursion, and no use of
                                        intersection shaders.
                                    </p>
                                    <p>
                                        Note that for procedural hit groups, the any-hit and intersection shaders will
                                        be merged at compile time. If a workload already utilizes an intersection
                                        shader, any-hit shaders can be added without additional thread dispatch
                                        overhead. In the case of an intersection shader paired with an any-hit shader,
                                        the Intel® Graphics driver will compile opaque and non-opaque variants of the
                                        intersection shader for each hit group. In the opaque variant, the intersection
                                        shader will simply track the closest hit, store it back to memory, and update
                                        the ray’s trace-distance value. In the nonopaque variant, the any-hit shader
                                        will be inlined into the intersection shader, and invoked directly during each
                                        call to
                                        <b>
                                            ReportHit().
                                        </b>
                                        This is the only likely scenario in which cross-stage communication can occur
                                        without passing data through the cache hierarchy.
                                    </p>
                                </div>
                            </section>
                            <section class="mt-5" id="VK_Understanding_Thread_Sorting_Unit">
                                <h3 class="VK_side_heading fw-light">
                                    Understanding the Thread Sorting Unit
                                </h3>
                                <p class="mb-3">
                                    Intel Arc GPUs incorporate a new hardware block called the thread sorting unit (TSU)
                                    to implement DXR shader dispatch. The TSU is a dedicated hardware block which is
                                    able to sort and re-emit shader threads to maximize SIMD coherence from divergent
                                    workloads. The operation of thread sorting is illustrated below:
                                </p>
                                <div>
                                    <img src="/img/vivek/VK_81.png" class="w-100" alt="">
                                </div>
                                <div class="my-3 py-4 px-3 VK_bg_e6">
                                    <p class="m-0">
                                        Figure 2. The thread sorting unit (TSU) is a dedicated hardware block that
                                        implements DXR shader dispatch.
                                    </p>
                                </div>
                                <div class="mt-5">
                                    <p>
                                        In the above diagram, five XVE threads are shown executing callable shaders. The
                                        different colors denote different target shader records. The numbers on the
                                        squares indicate the stack ID for the corresponding thread. The stack ID is a
                                        16-bit identifier which is used to recognize a particular work item across a
                                        sequence of bucketed dispatches.
                                    </p>
                                    <p>
                                        When an XVE thread wishes to dispatch a callable shader, it will send a
                                        <b>
                                            Bucketed Dispatch
                                        </b>
                                        message to the TSU, passing the stack ID and a 64-bit shader record address for
                                        each active SIMD lane. The TSU will bin the stack IDs by shader record address.
                                        It can then emit coherent XVE threads as they are formed, all of which will be
                                        the same shader, and share the same shader records. During binning, the stack
                                        IDs and shader-record addresses are stored in an on-chip sorting cache. Entries
                                        are evicted from the sorting cache whenever a full set of stack IDs is
                                        accumulated. If the workload is highly divergent, partially filled threads may
                                        need to be evicted in order to guarantee forward progress. Partially filled
                                        threads may also be evicted after a specified number of clock cycles, to prevent
                                        starvation at the tail end of a workload.
                                    </p>
                                    <p>
                                        Ray-tracing shaders are implemented using the same machinery, except that the
                                        dispatches are performed individually by the ray tracing hardware. For ray
                                        tracing shaders, the RTU receives a stack ID per ray as part of the trace
                                        message. When the hardware issues a shade request, it will forward this stack ID
                                        to the TSU together with the computed shader record address. For hit groups,
                                        which contain multiple types of shaders, the shader identifier will consist of a
                                        set of instruction pointers in a predefined order, and hardware will offset the
                                        shader record pointer based on shader type, before sending the dispatch to the
                                        TSU.
                                    </p>
                                    <p>
                                        At launch time, each hit-shader instance receives a 16-bit stack ID, a pointer
                                        to the shader record, which is used to fetch local arguments, and a global
                                        pointer which is used to access the global root signature, stack base address,
                                        dispatch dimensions, and other global constants. All other data is read and
                                        written by XVEs and ray-tracing hardware, as required.
                                    </p>
                                    <p>
                                        TSU dispatches are always scheduled to the same Xe-core as their parent shader,
                                        which means that a given child shader is restricted to a set of approximately 1K
                                        SIMD lanes. For extremely “bursty” workloads with unbalanced thread runtimes,
                                        multipass techniques using indirect dispatch may be more efficient than callable
                                        shaders, because they enable more effective load balancing.
                                    </p>
                                    <p>
                                        The TSU does not support work amplification, or concurrent execution between
                                        parent and child threads. Any thread which performs a
                                        <b>
                                            CallShader()
                                        </b>
                                        or
                                        <b>
                                            TraceRay()
                                        </b>
                                        must immediately terminate after sending the corresponding message. This is
                                        necessary to handle the corner case in which all other threads are fully loaded
                                        with other work, and the hardware must reuse the parent thread to execute child
                                        shaders.
                                    </p>
                                    <p class="mt-4">
                                        Whenever a TSU repacking point is encountered, the compiler will spill all live
                                        states to the ray’s stack, send the corresponding message, and terminate the
                                        thread. To emulate return semantics, the compiler will also push the address of
                                        a continuation shader record. Downstream shaders will be required to perform a
                                        dispatch back to the continuation shader record, which will reload the live
                                        state from the stack and execute the remainder of the parent shader. Figure 3
                                        illustrates this flow:
                                    </p>
                                    <div class="mt-4">
                                        <img src="/img/vivek/VK_82.png" class="w-100" alt="">
                                    </div>
                                    <div class="my-3 py-4 px-3 VK_bg_e6">
                                        <p class="m-0">
                                            Figure 3. Programming model for DXR.
                                        </p>
                                    </div>
                                    <div class="mt-4">
                                        <p>
                                            As can be seen in Figure 3, while the programming model for DXR presents the
                                            appearance of simple, sequential shader code within a single thread, the
                                            dynamic execution reality can be quite different. It is very important to
                                            comprehend this in shader code. For best performance, it is recommended to
                                            perform as much work as possible locally in DXR hit shaders, and to minimize
                                            ray payload size. It is also essential to avoid keeping a large number of
                                            values (large payload) live across a
                                            <b>
                                                TraceRay()
                                            </b>
                                            call. If possible,
                                            <b>
                                                TraceRay()
                                            </b>
                                            calls should ideally be tail recursive, as this will result in no live
                                            values by definition.
                                        </p>
                                        <p>
                                            The following code sample illustrates an undesirable
                                            <b>
                                                TraceRay()
                                            </b>
                                            call. There is excessive data communicated between shaders using the ray
                                            payload, and the 'TraceRay' call is not tail recursive.
                                        </p>
                                        <p>
                                            The value of 'color' must be saved and restored across the
                                            <b>
                                                TraceRay()
                                            </b>
                                            call.
                                        </p>
                                        <div class="bg-light border p-4 rounded-3">
                                            <code>
                                                
                                            </code>
                                        </div>
                                    </div>
                                </div>
                            </section>
                        </div>
                    </div>
                </div>
            </div>
            </div>
        </section>

        <!-- footer -->
        <footer>
            <div id="footer"></div>
        </footer>

    </main>


    <!---------------- Javascript Files ---------------->

    <!-- <script>
        // navbar include
        fetch('/y_index/y_navbar.html')
            .then(response => response.text())
            .then(data => {
                document.getElementById('navbar').innerHTML = data;
            });
        // footer include 
        fetch('/y_index/y_footer.html')
            .then(response => response.text())
            .then(data => {
                document.getElementById('footer').innerHTML = data;
            });
    </script> -->

    <!-- jquery -->
    <script src="/js/jquery-3.7.1.js"></script>


    <!-- bootstrap js file -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>

    <!-- costom js file -->
    <script src="/js/vivek.js"></script>

    <!-- all min -->
    <script src="/js/all.min.js"></script>

</body>

</html>