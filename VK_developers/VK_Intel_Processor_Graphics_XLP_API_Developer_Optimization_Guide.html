<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <!-- font family -->
    <link href="https://fonts.cdnfonts.com/css/intel-clear" rel="stylesheet">
    <!-- boootstap file -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <!-- costom css file -->
    <link rel="stylesheet" href="/css/vivek.css">
    <link rel="stylesheet" href="/css/yatri.css">

    <!-- all.min file -->
    <link rel="stylesheet" href="/css/all.min.css">

</head>

<body>


    <main>

        <!-- header -->
        <header>
            <div id="navbar"></div>
        </header>

        <!-- poster -->
        <section class=" VK_light_blue">
            <div class="VK_cont">
                <div class="row m-0">
                    <div class="col text-white">
                        <h1 class="VK_py_pre_heading fw-light m-0 py-4 mt-2">
                            Intel® Processor Graphics Xᵉ-LP API Developer and Optimization Guide
                        </h1>
                        <div
                            class="d-flex pb-4 col-md-4 col-sm-6 col-12 flex-md-row flex-column justify-content-between">
                            <div class="d-flex flex-md-column flex-row">
                                <p class="mb-2 me-3 w-100">
                                    ID
                                </p>
                                <p class="mb-2 me-3 w-100">
                                    676369
                                </p>
                            </div>
                            <div class="d-flex flex-md-column flex-row">
                                <p class="mb-2 me-3 w-100">
                                    Updated
                                </p>
                                <p class="mb-2 me-3 w-100">
                                    3/31/2023
                                </p>
                            </div>
                            <div class="d-flex flex-md-column flex-row">
                                <p class="mb-2 me-3 w-100">
                                    Version
                                </p>
                                <p class="mb-2 me-3 w-100">
                                    Latest
                                </p>
                            </div>
                            <div class="d-flex flex-md-column flex-row">
                                <p class="mb-2 me-3 d-none d-md-block">
                                    &nbsp;
                                </p>
                                <p class="mb-2 me-3 w-100">
                                    Public
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>


        <section>
            <div class="VK_cont py-5 VK_border_bottom">
                <div class="row m-0">
                    <div class="col-md-4 col-lg-3 d-md-block d-none">
                        <div class="VK_sticky_side_bar VK_side_bar_postion_stickey">
                            <div>
                                <div class="VK_sidebar_dropdown">
                                    <p class="m-0">
                                        <a href="#VK_Introduction" class="text-decoration-none VK_a">
                                            Introduction
                                        </a>
                                    </p>
                                    <details>
                                        <summary>
                                            <a href="#VK_Intel_XeLP_Architecture_Highlights"
                                                class="text-decoration-none VK_a">
                                                Intel® Xe-LP Architecture Highlights
                                            </a>
                                        </summary>
                                        <ul class="list-unstyled ps-4">
                                            <li>
                                                <a href="#VK_Variable_Rate_Shading"
                                                    class="text-decoration-none VK_a my-1">
                                                    Variable Rate Shading
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_High_Dynamic_Range_Displays"
                                                    class="text-decoration-none VK_a my-1">
                                                    High Dynamic Range Displays
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Adaptive_SyncVariable_Refresh_Rate"
                                                    class="text-decoration-none VK_a my-1">
                                                    Adaptive Sync—Variable Refresh Rate
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Dual_Queue_Support" class="text-decoration-none VK_a my-1">
                                                    Dual Queue Support
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_DirectX_View_Instancing_Vulkan_Multiview"
                                                    class="text-decoration-none VK_a my-1">
                                                    DirectX 12 View Instancing and Vulkan* Multiview
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_DirectX_Sampler_Feedback"
                                                    class="text-decoration-none VK_a my-1">
                                                    DirectX12 Sampler Feedback
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Other_API_Feature_Support"
                                                    class="text-decoration-none VK_a my-1">
                                                    Other API Feature Support
                                                </a>
                                            </li>
                                        </ul>
                                    </details>
                                    <details>
                                        <summary>
                                            <a href="#VK_Tools_Performance_Analysis" class="text-decoration-none VK_a">
                                                Tools for Performance Analysis
                                            </a>
                                        </summary>
                                        <ul class="list-unstyled ps-4">
                                            <li>
                                                <details>
                                                    <summary>
                                                        <a href="#VK_Intel_Graphics_Performance_Analyzers"
                                                            class="text-decoration-none VK_a">
                                                            Intel® Graphics Performance Analyzers
                                                        </a>
                                                    </summary>
                                                    <ul class="list-unstyled ps-4">
                                                        <li>
                                                            <a href="#VK_Graphics_Frame_Analyzer"
                                                                class="VK_a text-decoration-none">
                                                                Graphics Frame Analyzer
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_Graphics_Trace_Analyzer"
                                                                class="VK_a text-decoration-none">
                                                                Graphics Trace Analyzer
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_System_Analyzer"
                                                                class="VK_a text-decoration-none">
                                                                System Analyzer
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_Intel_GPA_Framework"
                                                                class="VK_a text-decoration-none">
                                                                Intel® GPA Framework
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_IntelGPA_Cookbook"
                                                                class="VK_a text-decoration-none">
                                                                Intel® GPA Cookbook
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_Intel_VTune_Profiler"
                                                                class="VK_a text-decoration-none">
                                                                Intel® VTune™ Profiler
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_Automatic_DirectX_Frame_Detection_Windows"
                                                                class="VK_a text-decoration-none">
                                                                Automatic DirectX* Frame Detection for Windows*
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_Frame_and_Event_API"
                                                                class="VK_a text-decoration-none">
                                                                Frame and Event API
                                                            </a>
                                                        </li>
                                                    </ul>
                                                </details>
                                            </li>
                                        </ul>
                                    </details>
                                    <details>
                                        <summary>
                                            <a href="#VK_Performance_Recommendations_Intel_Graphics_Processors"
                                                class="VK_a text-decoration-none">
                                                Performance Recommendations for Intel® Xe-LP Graphics Processors
                                            </a>
                                        </summary>
                                        <ul class="list-unstyled ps-4">
                                            <li>
                                                <a href="#VK_Configuring_Graphics_Pipeline_State"
                                                    class="VK_a text-decoration-none">
                                                    Configuring Graphics Pipeline State
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Resource_Binding" class="VK_a text-decoration-none">
                                                    Resource Binding
                                                </a>
                                            </li>
                                            <li>
                                                <details>
                                                    <summary>
                                                        <a href="#VK_Render_Targets_and_Textures"
                                                            class="VK_a text-decoration-none">
                                                            Render Targets and Textures
                                                        </a>
                                                    </summary>
                                                    <ul class="list-unstyled ps-4">
                                                        <li>
                                                            <a href="#VK_General_Guidance"
                                                                class="VK_a text-decoration-none">
                                                                General Guidance
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_UAVs_SSBOs" class="VK_a text-decoration-none">
                                                                UAVs and SSBOs
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_Anti_Aliasing"
                                                                class="VK_a text-decoration-none">
                                                                Anti-Aliasing
                                                            </a>
                                                        </li>
                                                    </ul>
                                                </details>
                                            </li>
                                            <li>
                                                <a href="#VK_Resource_Barriers" class="VK_a text-decoration-none">
                                                    Resource Barriers
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Command_Submissions" class="VK_a text-decoration-none">
                                                    Command Submissions
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Optimizing_Clear_Copy_Update_Operations"
                                                    class="VK_a text-decoration-none">
                                                    Optimizing Clear, Copy, and Update Operations
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Geometry_Transformation" class="VK_a text-decoration-none">
                                                    Geometry Transformation
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_TileBased_Rendering" class="VK_a text-decoration-none">
                                                    Tile-Based Rendering
                                                </a>
                                            </li>
                                            <li>
                                                <details>
                                                    <summary>
                                                        <a href="#VK_Shader_Optimizations"
                                                            class="VK_a text-decoration-none">
                                                            Shader Optimizations
                                                        </a>
                                                    </summary>
                                                    <ul class="list-unstyled">
                                                        <li>
                                                            <a href="#VK_General_Shader_Guidance"
                                                                class="VK_a text-decoration-none">
                                                                General Shader Guidance
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_Texture_Sampling"
                                                                class="VK_a text-decoration-none">
                                                                Texture Sampling
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_Constants" class="VK_a text-decoration-none">
                                                                Constants
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_Temporary_Register_Variable_Usage"
                                                                class="VK_a text-decoration-none">
                                                                Temporary Register Variable Usage
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_Compute_Shader_Considerations"
                                                                class="VK_a text-decoration-none">
                                                                Compute Shader Considerations
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_Wave_Intrinsics"
                                                                class="VK_a text-decoration-none">
                                                                Wave Intrinsics
                                                            </a>
                                                        </li>
                                                    </ul>
                                                </details>
                                            </li>
                                            <li>
                                                <a href="#VK_Frame_presentation" class="VK_a text-decoration-none">
                                                    Frame Presentation
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Dual_Queue_Support" class="VK_a text-decoration-none">
                                                    Dual Queue Support
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_CPU_performance_considerations"
                                                    class="VK_a text-decoration-none">
                                                    CPU performance considerations
                                                </a>
                                            </li>
                                        </ul>
                                    </details>
                                    <details>
                                        <summary>
                                            <a href="#VK_Design_Low_Power" class="VK_a text-decoration-none">
                                                Design for Low Power
                                            </a>
                                        </summary>
                                        <ul class="list-unstyled ps-4">
                                            <li>
                                                <a href="#VK_Idle_Active_Power" class="VK_a text-decoration-none">
                                                    Idle and Active Power
                                                </a>
                                            </li>
                                        </ul>
                                    </details>
                                    <details>
                                        <summary>
                                            <a href="#VK_Analysis_Tips" class="VK_a text-decoration-none">
                                                Analysis Tips
                                            </a>
                                        </summary>
                                        <ul class="list-unstyled ps-4">
                                            <li>
                                                <a href="#VK_Investigating_Idle_Power"
                                                    class="VK_a text-decoration-none">
                                                    Investigating Idle Power
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Active_Power_Speed_Shift"
                                                    class="VK_a text-decoration-none">
                                                    Active Power and Speed Shift
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_When_Reduce_Activity" class="VK_a text-decoration-none">
                                                    When and How to Reduce Activity
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Scale_Settings_Match_System_Power_Settings_Power_Profile"
                                                    class="VK_a text-decoration-none">
                                                    Scale Settings to Match System Power Settings and Power Profile
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Run_Slow_Remaining_Responsive"
                                                    class="VK_a text-decoration-none">
                                                    Run as Slow as You Can While Remaining Responsive
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Manage_Timers_Respect_System_Idle_Avoid_Tight_Polling_Loops"
                                                    class="VK_a text-decoration-none">
                                                    Manage Timers and Respect System Idle, Avoid Tight Polling Loops
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Multithread_Sensibility" class="VK_a text-decoration-none">
                                                    Multithread Sensibility
                                                </a>
                                            </li>
                                        </ul>
                                    </details>
                                    <p class="m-0">
                                        <a href="#VK_Using_CPU_SIMD" class="text-decoration-none VK_a">
                                            Using CPU SIMD
                                        </a>
                                    </p>
                                    <p class="m-0">
                                        <a href="#VK_Power_Versus_Frame_Rate" class="text-decoration-none VK_a">
                                            Power Versus Frame Rate
                                        </a>
                                    </p>
                                    <details>
                                        <summary>
                                            <a href="#VK_Additional_Resources_Intel_Developer_Zone_Game_Dev_Websites"
                                                class="text-decoration-none VK_a">
                                                Additional Resources on Intel® Developer Zone and Game Dev Websites
                                            </a>
                                        </summary>
                                        <ul class="list-unstyled ps-4">
                                            <li>
                                                <a href="#VK_Intel_Software_Developer_Zone_Game_Dev_Websites"
                                                    class="VK_a text-decoration-none">
                                                    Intel® Software Developer Zone and Game Dev Websites
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Dynamic_Resolution_Rendering"
                                                    class="VK_a text-decoration-none">
                                                    Dynamic Resolution Rendering
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Checkerboard_Rendering" class="VK_a text-decoration-none">
                                                    Checkerboard Rendering
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Conservative_Morphological_AntiAliasing"
                                                    class="VK_a text-decoration-none">
                                                    Conservative Morphological Anti-Aliasing 2.0
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Adaptive_Screen_Space_Ambient_Occlusion"
                                                    class="VK_a text-decoration-none">
                                                    Adaptive Screen Space Ambient Occlusion
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_GPU_Detect" class="VK_a text-decoration-none">
                                                    GPU Detect
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Fast_ISPC_Texture_Compression"
                                                    class="VK_a text-decoration-none">
                                                    Fast ISPC Texture Compression
                                                </a>
                                            </li>
                                            <li>
                                                <details>
                                                    <summary>
                                                        <a href="#VK_Additional_Resources"
                                                            class="VK_a text-decoration-none">
                                                            Additional Resources
                                                        </a>
                                                    </summary>
                                                    <ul class="ps-4 list-unstyled">
                                                        <li>
                                                            <a href="#VK_Revision_History"
                                                                class="VK_a text-decoration-none">
                                                                Revision History
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_Notices" class="VK_a text-decoration-none">
                                                                Notices
                                                            </a>
                                                        </li>
                                                    </ul>
                                                </details>
                                            </li>
                                        </ul>
                                    </details>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-12 col-md-8 col-lg-7">
                        <div class="VK_all_sections">
                            <div class="VK_section_descriptions">
                                <div class="text-end">
                                    <p class="m-0 VK_print_email_font">
                                        <span class="VK_a mx-2 d-inline-block">
                                            <i class="fa-solid fa-print"></i>
                                        </span>
                                        <span class="VK_a mx-2 d-inline-block">
                                            <i class="fa-regular fa-envelope"></i>
                                        </span>
                                    </p>
                                </div>
                            </div>
                            <section class="mt-5" id="VK_Introduction">
                                <h3 class="VK_side_heading">
                                    Introduction
                                </h3>
                                <p>
                                    If you are a developer seeking to optimize your games or interactive 3D rendering
                                    applications for Intel Processor Graphics and Dedicated Graphics with Xe-LP
                                    architecture, then you have come to the right place. The list of Xe-LP based
                                    platforms includes:
                                </p>
                                <ul>
                                    <li>
                                        11th Gen Intel® Core™ processor family (Codename Tiger Lake, Rocket Lake)
                                    </li>
                                    <li>
                                        12th Gen Intel® Core™ processor family (Codename Alder Lake)
                                    </li>
                                    <li>
                                        13th Gen Intel® Core™ processor family (Codename Raptor Lake)
                                    </li>
                                    <li>
                                        Intel® Iris® Xe Dedicated Graphics family (Codename DG1)
                                    </li>
                                </ul>
                                <p class="m-0">
                                    In this document, you will find optimization methods for the Xe-LP GPU architecture,
                                    best practices to most effectively harness the architecture’s capabilities and peak
                                    performance, and guidance for using the latest graphics application programming
                                    interfaces (APIs).
                                </p>
                                <p>
                                    It’s recommended that you bring a knowledge of the graphics API pipelines for
                                    Microsoft
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        DirectX 12*, Vulkan*,
                                    </a>
                                    and/or Metal* 2. Xe-LP GPUs supports the DirectX* 11 and
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        OpenGL*
                                    </a>
                                    graphics APIs, but the performance benefits with DirectX 12, Vulkan and Metal 2 are
                                    greater, and some new graphics architecture features are only available in these
                                    APIs.
                                </p>
                            </section>
                            <section class="mt-5" id="VK_Intel_XeLP_Architecture_Highlights">
                                <h3 class="VK_side_heading">
                                    Intel® Xe-LP Architecture Highlights
                                </h3>
                                <p>
                                    Xe-LP delivers new features such as coarse pixel shading, tile-based rendering, and
                                    display controller elements. In addition, Xe-LP offers the following improvements
                                    over previous generations:
                                </p>
                                <ul>
                                    <li>
                                        Compute capabilities that deliver up to 2.2 Teraflop performance
                                    </li>
                                    <li>
                                        Up to 96 execution units (EUs)
                                    </li>
                                    <li>
                                        Improved compression
                                    </li>
                                    <li>
                                        Significantly lower shared local memory (SLM) latency
                                    </li>
                                    <li>
                                        1.25x increase in L3 cache size over Gen11
                                    </li>
                                    <li>
                                        Increased memory bandwidth by 2x
                                    </li>
                                    <li>
                                        Improved multi-sample anti-aliasing (MSAA) performance
                                    </li>
                                    <li>
                                        Added support for new 10-bit float formats (R10B10G10_FLOAT_A2_UNORM)
                                    </li>
                                </ul>
                                <p>
                                    For a more in-depth overview of the Gen11 architecture and new features, access the
                                    guide here:
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Intel® Processor Graphics Gen11 Architecture
                                    </a>
                                </p>
                            </section>
                            <section class="mt-5" id="VK_Variable_Rate_Shading">
                                <p>
                                    Variable rate shading means the shading rate can be varied independently from the
                                    render target resolution and rasterization rate. This allows you to reduce the
                                    number of pixel shader invocations for content that has slow varying shading
                                    parameters, or for pixels that may be blurred later in the rendering pipeline. In
                                    short, you can direct shader operations to the pixels that matter the most. This
                                    provides a better visual solution than rendering at a lower resolution and then
                                    upscaling, as you preserve the depth and stencil at full pixel rate. Xe-LP hardware
                                    supports
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        DirectX 12 variable rate shading (VRS) Tier 1.
                                    </a>
                                    For more information on enabling VRS Tier 1 in your application, refer to the
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Get Started with Variable Rate Shading on Intel® Processor Graphics white paper.
                                    </a>
                                </p>
                            </section>
                            <section class="mt-5" id="VK_High_Dynamic_Range_Displays">
                                <h3 class="VK_side_heading">
                                    High Dynamic Range Displays
                                </h3>
                                <p>
                                    Xe-LP architecture features additional support and improvements for high dynamic
                                    range (HDR) images and displays. It’s integrated with FP16 for faster rendering
                                    speeds of deep color bit depths (10, 12, and 16 bits per channel), and has Dolby
                                    Vision* capable input.
                                    Xe-LP is fully compatible with the
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        VESA DisplayHDR*
                                    </a>
                                    and Ultra High Definition (UHD) Premium* display certifications, and already
                                    supports Dolby Vision* ahead of future consumer monitor releases.
                                    <br>
                                    For additional information on HDR, see:
                                    <br>
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Enabling HDR with Microsoft DirectX 11 and DirectX 12
                                    </a>
                                    <br>
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        High Dynamic Range and Wide Color Gamut
                                    </a>
                                </p>
                            </section>
                            <section class="mt-5" id="VK_Adaptive_SyncVariable_Refresh_Rate">
                                <h3 class="VK_side_heading">
                                    Adaptive Sync—Variable Refresh Rate
                                </h3>
                                <p>
                                    If application and platform conditions are met, the Xe-LP driver, by default,
                                    enables
                                    <a href="" class="VK_a Vk_text_underline_dots">
                                        Adaptive Sync
                                    </a>
                                    VESA-certified Adaptive Sync ensures a fast refresh rate for your display, reduces
                                    tearing and stuttering, and can lower overall system power consumption. Basic
                                    requirements for Adaptive Sync are:
                                </p>
                                <ul>
                                    <li>
                                        Full-screen rendering by the game or 3D application
                                    </li>
                                    <li>
                                        Simple application swap chain modification to ensure asynchronous buffer flips
                                    </li>
                                    <li>
                                        A Gen11 or later graphics device with DisplayPort 1.4 (or later) VESA Adaptive
                                        Sync support
                                    </li>
                                    <li>
                                        A DisplayPort 1.4 (or later) VESA Adaptive Sync capable display panel
                                    </li>
                                    <li>
                                        Windows* 10 RS5 and beyond
                                    </li>
                                </ul>
                                <p>
                                    The game, or 3D application, must ensure that its rendering swap-chain implements
                                    asynchronous buffer flips. On displays with Adaptive Sync, this results in smooth
                                    interactive rendering, with the display refresh dynamically synchronized with the
                                    asynchronous swap chain flips. Adaptive Sync can be disabled if you choose to, via
                                    the Intel graphics control panel. For more information, access this guide:
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Enabling Intel® Adaptive Sync.
                                    </a>
                                </p>
                            </section>
                            <section class="mt-5" id="VK_Dual_Queue_Support">
                                <h3 class="VK_side_heading">
                                    Dual Queue Support
                                </h3>
                                <p>
                                    With Xe-LP, independent scheduling queues allow the simultaneous residency and
                                    execution of up to two contexts from the same parent application. Dual residency of
                                    3D work and compute work then has minimal impact on performance.
                                </p>
                            </section>
                            <section class="mt-5" id="VK_DirectX_View_Instancing_Vulkan_Multiview">
                                <h3 class="VK_side_heading">
                                    DirectX 12 View Instancing and Vulkan* Multiview
                                </h3>
                                <p>
                                    This feature targets redundant geometry processing, such as when there is a shared
                                    use of the geometry between different views based on the position of the camera—each
                                    side of a cube map, for example, cascades of shadow maps, and/or stereo view.
                                </p>
                                <ul>
                                    <li>
                                        Usually, draw calls will be sent from the CPU to the GPU multiple times. This
                                        can become a bottleneck for scenes with a lot of objects or draw calls. Xe-LP
                                        enables replicating geometry for multiple views in a single pass. By converting
                                        multiple passes, or instances where the geometry is processed the same way to a
                                        single pass, Xe-LP avoids redundant CPU and GPU work.
                                    </li>
                                    <li>
                                        Xe-LP supports Tier 2 level of view instancing on D3D12, and works in
                                        conjunction with VRS for further performance gains.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-5" id="VK_DirectX_Sampler_Feedback">
                                <h3 class="VK_side_heading">
                                    DirectX12 Sampler Feedback
                                </h3>
                                <p>
                                    Sampler Feedback is a hardware-accelerated feature that was introduced in DirectX
                                    12.2 and is supported by Xe-LP. Conceptually, it is the reverse of texture sampling:
                                    the shader Sample() intrinsic reads a number of texels from a texture and returns an
                                    average value. The new WriteSamplerFeedback() shader intrinsic writes to a binary
                                    resource, "marking" the texels that would have been read. This enables two important
                                    usages:
                                </p>
                                <ol>
                                    <li>
                                        <b>
                                            Sampler Feedback Streaming:
                                        </b>
                                        when objects are drawn, we can simultaneously collect data about what texture
                                        data was required to draw the scene. By dynamically streaming only the visible
                                        portions of resources just-in-time, we can draw a scene that accesses more
                                        textures than could simultaneously fit in physical graphics memory, if they all
                                        had to be entirely physically resident. Sampler Feedback includes a "min mip
                                        map" feature to facilitate this usage: a single-layer texture where each texel
                                        represents a region of the streaming texture. Each texel is an integer (byte)
                                        representing the minimum mip that was sampled in that region. If the sampler
                                        feedback region size is set to match the tile-size of a reserved resource, the
                                        result is a map that informs what tiles to stream. Min-mip-maps are very
                                        small—for example, for a 16kx16k BC7 reserved resource, the corresponding
                                        sampler feedback min-mip-map, with region size 256x256, is only 64x64 bytes or
                                        4KB in size, and represents a 350MB texture.
                                    </li>
                                    <li>
                                        <b>
                                            Texture Space Rendering:
                                        </b>
                                        Texture-Space Rendering was pioneered by Intel in a Siggraph 2014 research paper
                                        [Clarberg et al. 2014]. At that time, we observed that the cost of pixel shading
                                        is tightly coupled to both the geometric complexity and the screen resolution
                                        which has only increased over time as workloads enable richer visual environment
                                        using tessellation, complex lighting calculations using pixel shading and higher
                                        resolution displays. Instead of shading directly through traditional pixel
                                        shaders, the application uses Sampler Feedback to mark a mask which corresponds
                                        to the texels it requires. This mask can then be referenced in a subsequent
                                        compute shader pass, and the required texels can be shaded at a resolution and
                                        frequency determined by the developer in texture space as opposed to a fixed
                                        screen space resolution and frame frequency. Once shading to texels is
                                        completed, in a separate lighter-weight pass, pixels in screen-space are mapped
                                        into texture space, and the corresponding texels are sampled and filtered using
                                        standard texture lookup operations. This feature allows pixel shading to be
                                        largely independent of the geometric complexity or screen resolution and adds
                                        new texture LOD methods to control level of shading detail. These abilities are
                                        introduced to temporally decouple the shading pipeline from the traditional
                                        sample, pixel or coarse shading rates. AMFS can provide sizable gains over
                                        traditional pixel shader approaches as shader complexity, geometry or MSAA
                                        samples increases.
                                    </li>
                                </ol>
                            </section>
                            <section class="mt-5" id="VK_Other_API_Feature_Support">
                                <h3 class="VK_side_heading">
                                    Other API Feature Support
                                </h3>
                                <p>
                                    The table below illustrates which features that are part of the D3D12 map to ICL and
                                    Xe-LP products, as well as correspond to Vulkan.
                                </p>
                                <div>
                                    <img src="/img/vivek/VK_99.jpg" class="w-100" alt="">
                                </div>
                            </section>
                            <section class="mt-5" id="VK_Tools_Performance_Analysis">
                                <h3 class="VK_side_heading">
                                    Tools for Performance Analysis
                                </h3>
                                <p>
                                    When optimizing, you want to measure the benefit. Intel provides two major tools to
                                    help improve application performance on both CPUs and GPUs
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Intel® Graphics Performance Analyzers (Intel® GPA)
                                    </a>
                                    and
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Intel® VTune™ Profiler
                                    </a>
                                    are both free to download.
                                </p>
                            </section>
                            <section class="mt-5" id="VK_Intel_Graphics_Performance_Analyzers">
                                <h3 class="VK_side_heading">
                                    Intel® Graphics Performance Analyzers
                                </h3>
                                <div>
                                    <img src="/img/vivek/VK_100.png" class="w-100" alt="">
                                </div>
                                <p>
                                    Intel GPA is a suite of powerful, agile tools that enable you to use the full
                                    performance potential of your gaming platform, including, though not limited to,
                                    Intel® Core™ processors and Intel GPA.
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Intel® GPA
                                    </a>
                                    Intel GPA tools visualize performance data from your application, enabling you to
                                    understand from system-level to individual frame performance issues.
                                </p>
                            </section>
                            <section class="mt-5" id="VK_Graphics_Frame_Analyzer">
                                <h3 class="VK_side_heading">
                                    Graphics Frame Analyzer
                                </h3>
                                <p>
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Graphics Frame Analyzer
                                    </a>
                                    is a powerful, intuitive, single frame and multi frame (DirectX 11, DirectX 12, and
                                    Vulkan*) analysis and optimization tool. It provides deep frame performance analysis
                                    down to the draw call level, including shaders, render states, pixel history, and
                                    textures. You can conduct what-if experiments to see how changes iteratively impact
                                    performance and visuals without having to recompile your source code.
                                </p>
                                <p>
                                    With
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Graphics Frame Analyzer
                                    </a>
                                    you can:
                                </p>
                                <ul>
                                    <li>
                                        Graph draw calls to identify most expensive calls manually.
                                    </li>
                                    <li>
                                        Use the powerful Hotspot Analysis mode to automatically identify the most
                                        problematic calls and their bottlenecks.
                                    </li>
                                    <li>
                                        Analyze execution of shaders in Shader Profiler.
                                    </li>
                                    <li>
                                        View the history of any given pixel.
                                    </li>
                                    <li>
                                        Apply various experiments to quickly assess the potential impact in performance
                                        and visual quality of an optimization.
                                    </li>
                                    <li>
                                        Study the geometry, wireframe, and overdraw view of any frame.
                                    </li>
                                    <li>
                                        Automate and streamline multiple aspects of your profiling workflow using the
                                        Python* plug-in interface.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-5" id="VK_Graphics_Trace_Analyzer">
                                <h3 class="VK_side_heading">
                                    Graphics Trace Analyzer
                                </h3>
                                <p>
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Graphics Trace Analyzer
                                    </a>
                                    is a time-based trace capture tool which gives deeper insight into the execution
                                    flow of an application and the system. This can help you ensure that your software
                                    takes full advantage of the processing power available from today’s Intel®
                                    platforms.
                                </p>
                                <p>
                                    With
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Graphics Trace Analyzer
                                    </a>,
                                    you can:
                                </p>
                                <ul>
                                    <li>
                                        Correlate system and per-application data on one timeline from various data
                                        sources (ETW, ITT, graphics API, sampled metrics, etc.)
                                    </li>
                                    <li>
                                        Identify CPU and GPU bound applications by exploring CPU threads and GPU
                                        hardware and per-context driver queues.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-5" id="VK_System_Analyzer">
                                <h3 class="VK_side_heading">
                                    System Analyzer
                                </h3>
                                <p>
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        System Analyzer
                                    </a>
                                    is a real-time tool that displays CPU, graphics API, and GPU
                                    performance metrics. System Analyzer can help you quickly identify key performance
                                    opportunities and whether your workload is CPU or GPU bottlenecked—allowing you to
                                    focus optimization efforts on elements that have the most performance impact on your
                                    application.
                                </p>
                                <p>
                                    With
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        System Analyzer
                                    </a>
                                    you can:
                                </p>
                                <ul>
                                    <li>
                                        Display real-time system and per-process metrics.
                                    </li>
                                    <li>
                                        Metrics available include data from the CPU, GPU, graphics driver, graphic APIs,
                                        and FPS.
                                    </li>
                                    <li>
                                        Perform various what-if experiments using override modes to quickly isolate many
                                        common performance bottlenecks.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-5" id="VK_Intel_GPA_Framework">
                                <h3 class="VK_side_heading">
                                    Intel® GPA Framework
                                </h3>
                                <p>
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Intel® GPA Framework
                                    </a>
                                    is a cross-platform, cross-API suite of tools and interfaces, which allows users to
                                    capture, playback and analyze graphics applications.
                                </p>
                                <p>
                                    In a nutshell, an
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Intel® GPA Framework
                                    </a>
                                    user can do a real time analysis of a running application using custom layers,
                                    capture a multi frame stream of a running application starting either from
                                    application startup or an arbitrary point of time, playback the stream to recreate
                                    the application graphics execution or create a script that can play back a stream up
                                    to a given frame, get a list of API calls, get metrics, and produce a performance
                                    regression report.
                                </p>
                            </section>
                            <section class="mt-5" id="VK_IntelGPA_Cookbook">
                                <h3 class="VK_side_heading">
                                    Intel® GPA Cookbook
                                </h3>
                                <p>
                                    To help debug performance issues, the GPA cookbook provides performance analysis
                                    scenarios to help solve performance issues in your application across different
                                    parts of the hardware, from shader execution to sampler operations. It also provides
                                    descriptions of the metrics found in GPA Frame Analyzer. To use this guide, see
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        The Intel Graphics Performance Analyzers Cookbook.
                                    </a>
                                </p>
                            </section>
                            <section class="mt-5" id="VK_Intel_VTune_Profiler">
                                <h3 class="VK_side_heading">
                                    Intel® VTune™ Profiler
                                </h3>
                                <p>
                                    Intel® VTune™ Profiler can assist not only with finding CPU or GPU bottlenecks, it
                                    can also help to optimize work being done by the CPU when tuning for performance.
                                    For tuning performance on DirectX applications, Intel® VTune™ Profiler can detect
                                    slow frames and detect DirectX events. Intel® VTune™ Profiler also supports
                                    customization of tracing events through its Frame and Event APIs. For more
                                    information on how to set up and use Intel® VTune™ Profiler, see the extensive
                                    documentation on Intel® VTune™ Profiler in the
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Intel® VTune™ Profiler User Guide.
                                    </a>
                                </p>
                                <p>
                                    While the scope of this guide is only limited to performance optimizations on Xe-LP,
                                    this guide provides an overview of key features that are helpful for developers when
                                    tuning performance on workloads that are more graphical in nature, such as gaming
                                    applications.
                                </p>
                            </section>
                            <section class="mt-5" id="VK_Automatic_DirectX_Frame_Detection_Windows">
                                <h3 class="VK_side_heading">
                                    Automatic DirectX* Frame Detection for Windows*
                                </h3>
                                <p>
                                    Intel® VTune™ Profiler can detect slow frames and detect DirectX events. Using this,
                                    you can identify slow frames and filter the events in that frame.
                                </p>
                            </section>
                            <section class="mt-5" id="VK_Frame_and_Event_API">
                                <h3 class="VK_side_heading">
                                    Frame and Event API
                                </h3>
                                <p>
                                    Using the Frame and Event API in Intel® VTune™ Profiler allows for the customization
                                    of tracing events that can be profiled by Intel® VTune™ Profiler. The Frame API
                                    allows for this to be done on a per frame basis. For instance, in a game
                                    application, it is best to surround the game loop with begin and end events to
                                    profile per frame. More information and examples on the Intel® VTune™ Profiler Frame
                                    API can be found in the
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Frame API documentation.
                                    </a>
                                </p>
                                <p>
                                    The Event API allows for custom demarcation of events in your software for
                                    profiling. For instance, to help optimize tasks in a game, you could use the Event
                                    API to track individual tasks needed to compute a frame in a gaming application.
                                    More information and usage on the Intel® VTune™ Profiler Event API can be found in
                                    the
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Event API documentation.
                                    </a>
                                </p>
                            </section>
                            <section class="mt-5" id="VK_Performance_Recommendations_Intel_Graphics_Processors">
                                <h3 class="VK_side_heading fw-light">
                                    Performance Recommendations for Intel® Xe-LP Graphics Processors
                                </h3>
                                <p>
                                    DirectX 12, Metal, and Vulkan give developers more control over lower-level choices
                                    that were once handled in driver implementations. Although each API is different,
                                    there are general recommendations for application developers that are
                                    API-independent.
                                </p>
                            </section>
                            <section class="mt-5" id="VK_Configuring_Graphics_Pipeline_State">
                                <h3>
                                    Configuring Graphics Pipeline State
                                </h3>
                                <p>
                                    When configuring pipeline states, consider the following:
                                </p>
                                <ul>
                                    <li>
                                        When creating Pipeline State Objects (PSOs), make sure to take advantage of all
                                        the available CPU threads on the system. In previous APIs, the driver would
                                        create these threads for you, but now you must create the threads yourself.
                                    </li>
                                    <li>
                                        Compile similar PSOs on the same thread to improve deduplication done by the
                                        driver and runtime.
                                    </li>
                                    <li>
                                        Define optimized shaders for PSOs instead of using combinations of generic
                                        shaders mixed with specialized shaders.
                                    </li>
                                    <li>
                                        Avoid defining depth plus stencil format if stencil will not be used. Use
                                        depth-only formats, such as D32.
                                    </li>
                                    <li>
                                        The driver will attempt to reuse shader compilations from PSOs it has already
                                        created. However, certain differences between PSOs could lead to the same shader
                                        code being recompiled again. Factors and changes that could cause a given stage
                                        to be recompiled include but are not limited to:
                                        <ul>
                                            <li>
                                                Vertex Shader
                                                <ul>
                                                    <li>
                                                        pRootSignature
                                                    </li>
                                                    <li>
                                                        InputLayout
                                                    </li>
                                                    <li>
                                                        ViewInstancingDesc
                                                    </li>
                                                    <li>
                                                        Using SV_ViewID in a subsequent stage
                                                    </li>
                                                    <li>
                                                        The input signature for the subsequent stage
                                                    </li>
                                                </ul>
                                            </li>
                                            <li>
                                                Hull Shader
                                                <ul>
                                                    <li>
                                                        pRootSignature
                                                    </li>
                                                    <li>
                                                        Using SV_ViewID in a subsequent stage
                                                    </li>
                                                    <li>
                                                        The input signature for the DS
                                                    </li>
                                                </ul>
                                            </li>
                                            <li>
                                                Domain Shader
                                                <ul>
                                                    <li>
                                                        pRootSignature
                                                    </li>
                                                    <li>
                                                        ViewInstancingDesc
                                                    </li>
                                                    <li>
                                                        Using SV_ViewID in a subsequent stage
                                                    </li>
                                                    <li>
                                                        The input signature for the subsequent stage
                                                    </li>
                                                </ul>
                                            </li>
                                            <li>
                                                Geometry Shader
                                                <ul>
                                                    <li>
                                                        pRootSignature
                                                    </li>
                                                    <li>
                                                        ViewInstancingDesc
                                                    </li>
                                                    <li>
                                                        Using SV_ViewID in a subsequent stage
                                                    </li>
                                                    <li>
                                                        The input signature for the PS
                                                    </li>
                                                </ul>
                                            </li>
                                            <li>
                                                Pixel Shader
                                                <ul>
                                                    <li>
                                                        pRootSignature
                                                    </li>
                                                    <li>
                                                        BlendState
                                                    </li>
                                                    <li>
                                                        RasterizerState.ForcedSampleCount
                                                    </li>
                                                    <li>
                                                        RasterizerState.ConservativeRasterization
                                                    </li>
                                                    <li>
                                                        DepthStencilState.StencilEnable
                                                    </li>
                                                    <li>
                                                        NumRenderTargets
                                                    </li>
                                                    <li>
                                                        SampleDesc.Count
                                                    </li>
                                                </ul>
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-5" id="VK_Resource_Binding">
                                <h3 class="VK_side_heading">
                                    Resource Binding
                                </h3>
                                <p>
                                    Modern Graphics APIs give you more control over resource binding, such as with
                                    DirectX Root Signatures and Vulkan* Pipeline Layout. Using these requires particular
                                    attention to maximize performance. When designing an application strategy for
                                    resource binding, employ the following guidance:
                                </p>
                                <ul>
                                    <li>
                                        Minimize the number of root signature slots or descriptor sets to only what will
                                        be used by a shader.
                                    </li>
                                    <li>
                                        Try to find a balance between root signature or descriptor set reuse across
                                        shaders.
                                    </li>
                                    <li>
                                        For multiple constant buffers that do not change between draws, consider packing
                                        all constant buffer views into one descriptor table.
                                    </li>
                                    <li>
                                        For multiple Unordered Access Views (UAVs) and Shader Resource Views (SRVs) that
                                        do not span a consecutive range of registers and do not change between draws, it
                                        is best to pack them into a descriptor table.
                                    </li>
                                    <li>
                                        Minimize descriptor heap changes. Changing descriptor heaps severely stalls the
                                        graphics pipeline. Ideally, all resources will have views appropriated out of
                                        one descriptor heap.
                                    </li>
                                    <li>
                                        Avoid generic root signature definitions where unnecessary descriptors are
                                        defined and not leveraged. Instead, optimize root signature definitions to the
                                        minimal set of descriptor tables needed.
                                        <ul>
                                            <li>
                                                Vulkan: When creating a Descriptor Set, using the BindAfterFlag bit
                                                beware that
                                                Xe-LP only supports 1M Descriptors. Only Create needed descriptors (when
                                                porting
                                                from DX12, remember that D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV maps to
                                                7 Vulkan
                                                types [ VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, *_STORAGE_IMAGE,*
                                                _UNIFORM_TEXEL_BUFFER,*_STORAGE_TEXEL_BUFFER, *_UNIFORM_BUFFER,
                                                *_STORAGE_BUFFER])
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        Favor root constants over root descriptors, and favor root descriptors over
                                        descriptor tables when working with constants.
                                        <ul>
                                            <li>
                                                Make use of root/push constants to enable fast access to constant buffer
                                                data
                                                (they are pre-loaded into registers).
                                            </li>
                                            <li>
                                                Root/push constants are great to use on frequently changing constant
                                                buffer data.
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        Use root/push constants for cases where the constants are changing at a high
                                        frequency.
                                        <ul>
                                            <li>
                                                If certain Root Signature slots are less frequently used (not referenced
                                                by a PSO), put those at the end of the root signature to reduce GRF
                                                usage
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        Be sure to use hints that allow the driver to perform constant-based
                                        optimizations, such as D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC.
                                    </li>
                                    <li>
                                        For placed resources, initialize with a clear, copy, or discard before rendering
                                        to the resource. This helps enable proper compression by putting the placed
                                        resource into a valid state.
                                    </li>
                                    <li>
                                        When creating resource heaps, resources that need to be accessed by the GPU
                                        should be placed in heaps that are declared as resident in GPU memory,
                                        preferably exclusively. This has a significant impact on discrete GPU
                                        performance.
                                    </li>
                                    <li class="mt-4">
                                        Use queries to identify scenarios when GPU local memory gets oversubscribed and
                                        adjust resource location to accommodate this.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-5" id="VK_Render_Targets_and_Textures">
                                <h3 class="VK_side_heading">
                                    Render Targets and Textures
                                </h3>
                            </section>
                            <section class="mt-3" id="VK_General_Guidance">
                                <h3 class="VK_n22">
                                    General Guidance
                                </h3>
                                <p>
                                    The following application guidelines ensure the efficient use of bandwidth with
                                    render targets:
                                </p>
                                <ul>
                                    <li>
                                        Use as few render targets as necessary and combine render targets when possible,
                                        to make better use of lower-level caches.
                                    </li>
                                    <li>
                                        Avoid defining unnecessary channels or higher precision data formats when not
                                        needed to conserve memory bandwidth and optimize cache fetches
                                    </li>
                                    <li>
                                        Create multiple resources from the same memory object.
                                    </li>
                                    <li>
                                        When possible, create resources in the state that they will first be used. For
                                        example, starting in COMMON state then transitioning to DEPTH_WRITE will cause a
                                        Hi-Z resolve. Starting in DEPTH_WRITE this example is optimal.
                                    </li>
                                    <li>
                                        Vulkan specific for optimal device access:
                                        <ul>
                                            <li>
                                                Always use VK_IMAGE_LAYOUT_{}_OPTIMAL for GPU access.
                                            </li>
                                            <li>
                                                Only use VK_IMAGE_LAYOUT_GENERAL when really needed.
                                            </li>
                                            <li>
                                                Only use VK_IMAGE_CREATE_MULTIPLE_FORMAT_BIT when really needed.
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_UAVs_SSBOs">
                                <h3 class="VK_n22">
                                    UAVs and SSBOs
                                </h3>
                                <p>
                                    When dealing with resources that have both read- and write-access in a shader, such
                                    as UAVs and shader storage buffer objects (SSBOs), consider the following:
                                </p>
                                <ul>
                                    <li>
                                        These resource types may cause inefficient partial writes over the Xe-LP 64-byte
                                        cache lines. Avoid these partial writes to get maximum bandwidth through the
                                        cache hierarchy. This can be done by ensuring that a single thread executing a
                                        given shader on a 4x2 group of pixels writes a contiguous 64 bytes on its own
                                        for output.
                                    </li>
                                    <li>
                                        Access to read-only data is much more efficient than read/write data. Use these
                                        kinds of resources with caution, or when there are no better options.
                                    </li>
                                    <li>
                                        Do not set a resource to use a UAV bind flag if the resource will never be bound
                                        as a UAV. This programming behavior may disable resource compression.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Anti_Aliasing">
                                <h3 class="VK_n22">
                                    Anti-Aliasing
                                </h3>
                                <p>
                                    To get the best performance when performing multisample anti-aliasing, the following
                                    are recommended:
                                </p>
                                <ul>
                                    <li>
                                        Minimize the use of stencil or blend when MSAA is enabled.
                                    </li>
                                    <li>
                                        Avoid querying resource information from within a loop or branch where the
                                        result is immediately consumed or duplicated across loop iterations.
                                    </li>
                                    <li>
                                        Minimize per-sample operations. When shading per sample, maximize the number of
                                        cases where any kill pixel operation is used to get the best surface
                                        compression.
                                    </li>
                                </ul>
                                <p>
                                    We do recommend using optimized post-processing anti-aliasing such as Temporal
                                    Anti-Aliasing and/or
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Conservative Morphological Anti-Aliasing 2.0.
                                    </a>
                                </p>
                            </section>
                            <section class="mt-4" id="VK_Resource_Barriers">
                                <h3 class="VK_n22">
                                    Resource Barriers
                                </h3>
                                <p>
                                    Each resource barrier generally results in a cache flush or GPU stall operation,
                                    affecting performance. Given that, the following guidelines are recommended:
                                </p>
                                <ul>
                                    <li>
                                        Batch pipeline barriers and use render passes to help properly batch barriers
                                        and allow the driver to defer and hoist barriers to render pass edges.
                                    </li>
                                    <li>
                                        Avoid command buffers that include only barriers. If needed, put these barriers
                                        at the end of the command queue.
                                    </li>
                                    <li>
                                        Use implicit render pass barriers when possible.
                                    </li>
                                    <li>
                                        Limit the number of resource transitions by batching them and avoid interleaving
                                        with dispatches/render passes.
                                    </li>
                                    <li>
                                        Generally, avoid barriers outside of render target changes and avoid states like
                                        D3D12_RESOURCE_STATE_COMMON unless necessary for presenting, context sharing, or
                                        CPU access.
                                    </li>
                                    <li>
                                        When possible, supply resources for barriers; they allow more optimal GPU cache
                                        flushing, especially for aliasing buffers.
                                    </li>
                                    <li>
                                        When possible, employ split barriers to allow for maximum predication of
                                        synchronizing events.
                                    </li>
                                    <li>
                                        When transitioning resource states, do not over-set them when not in use; it can
                                        lead to excessive cache flushes.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Command_Submissions">
                                <h3 class="VK_n22">
                                    Command Submissions
                                </h3>
                                <p class="m-0">
                                    When working with command queues and buffers, the following are recommended:
                                </p>
                                <ul>
                                    <li>
                                        Batch command list submission at ExecuteCommandLists in DirectX 12 when
                                        possible, but not to the point where the GPU is starved. This ensures efficient
                                        use of the CPU and GPU.
                                    </li>
                                    <li>
                                        When filling command buffers or command queues, use multiple CPU cores when
                                        possible. This reduces single core CPU bottlenecking of your application. Using
                                        <a href="" class="Vk_text_underline_dots VK_a">
                                            Intel® Threading Building Blocks
                                        </a>
                                        (Intel® TBB) can help.
                                    </li>
                                    <li>
                                        Use reusable command buffers with caution.
                                    </li>
                                    <li>
                                        DirectX 12 specific:
                                        <ul>
                                            <li>
                                                Avoid the overuse of bundles as they may incur additional CPU and GPU
                                                overhead.
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        Vulkan specific:
                                        <ul>
                                            <li>
                                                Use primary command buffers where possible as these provide better
                                                performance due to internal batch buffer usage.
                                            </li>
                                            <li>
                                                For primary command buffers, use USAGE_ONE_TIME_SUBMIT_BIT.
                                            </li>
                                            <li>
                                                For primary command buffers, avoid USAGE_SIMULTANEOUS_USE_BIT.
                                            </li>
                                            <li>
                                                Minimize the use of secondary command buffers as they are less efficient
                                                than primary command buffers and not as efficient with depth clears.
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Optimizing_Clear_Copy_Update_Operations">
                                <h3 class="VK_n22">
                                    Optimizing Clear, Copy, and Update Operations
                                </h3>
                                <p>
                                    For the best performance on clear, copy, and update operations, follow these
                                    guidelines:
                                </p>
                                <ul>
                                    <li>
                                        Use the API provided functions for clear, copy, and update operations, and
                                        refrain from implementing your own versions. Drivers have been optimized and
                                        tuned to ensure that these operations work with the best possible performance.
                                    </li>
                                    <li>
                                        Enable hardware “fast clear” values as defined per API:
                                        <ul>
                                            <li>
                                                In DirectX 12, clear values are defined at resource creation as an
                                                argument with ID3D12Device::CreateCommittedResource.
                                            </li>
                                            <li>
                                                For Vulkan, use VK_ATTACHMENT_LOAD_OP_CLEAR and avoid using
                                                vkCmdClearColorImage.
                                            </li>
                                            <li>
                                                Ensure horizontal alignment = 128b and vertical alignment = 64b.
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        Copy depth and stencil surfaces only as needed instead of copying both
                                        unconditionally; they are stored separately on Xe-LP.
                                    </li>
                                    <li>
                                        Batch blit and copy operations.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Geometry_Transformation">
                                <h3 class="VK_n22">
                                    Geometry Transformation
                                </h3>
                                <p class="m-0">
                                    Ensure that vertex and geometry shader functions operate optimally by following
                                    these guidelines:
                                </p>
                                <ul>
                                    <li>
                                        Vertex fetch throughput is eight attributes per clock (and max two vertices per
                                        clock). Ensure all bound attributes are used. When a draw is bottlenecked on
                                        geometry work, reduce the number of attributes per vertex to improve
                                        performance.
                                    </li>
                                    <li>
                                        Implement a level of detail system that allows flexibility in model accuracy by
                                        adjusting the number of vertices per model per level of detail.
                                    </li>
                                    <li>
                                        Analyze primitive to pixels covered ratios. When this ratio is high, the extra
                                        vertex shader threads add very little value to the final render target. Keep
                                        this ratio below 1:4.
                                    </li>
                                    <li>
                                        Implement efficient CPU occlusion culling to avoid submitting hidden geometry.
                                        This approach can save both CPU (draw submission), and GPU (render) time—we
                                        suggest using our highly optimized
                                        <a href="" class="Vk_text_underline_dots VK_a">
                                            Masked Software Occlusion Culling
                                        </a>
                                        It can eventually be used in combination to finer grain GPU culling.
                                    </li>
                                    <li>
                                        Define input geometries as a structure of arrays for vertex buffers. Try to
                                        group position information vertex data in its own input slot to assist the tile
                                        binning engine for tile-based rendering.
                                    </li>
                                    <li>
                                        The Xe-LP vertex cache does not cache instanced attributes. For instanced calls,
                                        consider loading attributes explicitly in your vertex shader.
                                    </li>
                                    <li>
                                        For full-screen post-processing passes, use a single triangle that covers entire
                                        screen space instead of two triangles to form a quad. The shared triangle edge
                                        in the two tri-case results in sub-optimal utilization of compute resources.
                                    </li>
                                    <li>
                                        Optimize transformation shaders (that is, vertex to geometry shader) to output
                                        only attributes that will be used by later stages in the pipeline. For example,
                                        avoid defining unnecessary outputs from a vertex shader that will not be
                                        consumed by a pixel shader. This enables better use of bandwidth and space with
                                        the L3 cache.
                                    </li>
                                    <li>
                                        Metal 2 Specific—Tessellation factors are calculated in the compute engine, then
                                        returned to the 3D engine to get rendered. Calculate tessellation factors
                                        back-to-back for multiple draws to reduce the amount of context switching
                                        between 3D and compute workloads.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_TileBased_Rendering">
                                <h3 class="VK_n22">
                                    Tile-Based Rendering
                                </h3>
                                <p>
                                    To ensure the most efficient use of Xe-LP tile-based hardware, follow these
                                    guidelines for bandwidth limited passes:
                                </p>
                                <ul>
                                    <li>
                                        Only use trilist or tristrip topologies.
                                    </li>
                                    <li>
                                        For DirectX 12, use ID3D12GraphicsCommandList4::EndRenderPass with
                                        <br>
                                        D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_DISCARD.
                                    </li>
                                    <li>
                                        For Vulkan, use VkRenderPass/VkSubpass with VK_ATTACHMENT_STORE_OP_DONT_CARE.
                                    </li>
                                    <li>
                                        Avoid tessellation, geometry, and compute shaders. Passes with tessellation and
                                        geometry shaders will not benefit from hardware improvements.
                                    </li>
                                    <li>
                                        Avoid intra-render pass read after write hazards.
                                    </li>
                                    <li>
                                        Separate the attributes required to compute position into separate vertex
                                        buffers.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Shader_Optimizations">
                                <h3 class="VK_side_heading">
                                    Shader Optimizations
                                </h3>
                            </section>
                            <section class="mt-4" id="VK_General_Shader_Guidance">
                                <h3 class="VK_n22">
                                    General Shader Guidance
                                </h3>
                                <p>
                                    When writing shaders, look for these opportunities to optimize:
                                </p>
                                <ul>
                                    <li>
                                        Xe-LP supports double-rate FP16 math. Use lower precision when possible. Also,
                                        note that Xe-LP removed FP64 support to improve power and performance. Make sure
                                        that you query hardware support for double-rate, and ensure proper fallback.
                                    </li>
                                    <li>
                                        Structure the shader to avoid unnecessary dependencies, especially high latency
                                        operations such as sampling or memory fetches.
                                    </li>
                                    <li>
                                        Avoid shader control flow based on results from sampling operations.
                                    </li>
                                    <li>
                                        Aim for uniform execution of shaders by avoiding flow control based on
                                        non-uniform variables.
                                    </li>
                                    <li>
                                        Implement early returns in shaders where the output of an algorithm can be
                                        predetermined or computed at a lower cost of the full algorithm.
                                    </li>
                                    <li>
                                        Use shader semantics to flatten, branch, loop, and unroll wisely. It is often
                                        better to explicitly specify the desired unrolling behavior, rather than let the
                                        shader compiler make those decisions.
                                    </li>
                                    <li>
                                        Branching is preferable if there are enough instruction cycles saved that
                                        outweigh the cost of branching
                                    </li>
                                    <li class="mt-3">
                                        Extended math and sampling operations have a higher weight, and may be worth
                                        branching (see table below for issue rate).
                                    </li>
                                </ul>
                                <div class="d-flex justify-content-center">
                                    <div class="col-md-7">
                                        <img src="/img/vivek/VK_101.png" class="w-100" alt="">
                                    </div>
                                </div>
                                <ul>
                                    <li>
                                        Small branches of code may perform better when flattened.
                                    </li>
                                    <li>
                                        Unroll conservatively. In most cases, unrolling short loops helps performance;
                                        however, unrolling loops does increase the shader instruction count. Unrolling
                                        long loops with high iteration counts can impact shader residency in instruction
                                        caches, and therefore negatively impact performance.
                                    </li>
                                    <li>
                                        Avoid extra sampler operations when it is possible that the sampler operation
                                        will later be multiplied by zero. For example, when interpolating between two
                                        samples, if there is a high probability of the interpolation being zero or one,
                                        a branch can be added to speed up the common case and only perform the load only
                                        when needed.
                                    </li>
                                    <li>
                                        Avoid querying resource information at runtime. For example, High-Level Shading
                                        Language (HLSL) GetDimensions call to make decisions on control flow, or
                                        unnecessarily incorporating resource information into algorithms.
                                    </li>
                                    <li>
                                        When passing attributes to the pixel shader, mark attributes that do not change
                                        per vertex within a primitive as constant.
                                    </li>
                                    <li>
                                        For shaders where depth test is disabled, use discard (or other kill operations)
                                        where output will not contribute to the final color in the render target.
                                        Blending can be skipped where the output of the algorithm has an alpha channel
                                        value of zero, or when adding inputs into shaders that are zeros that negate
                                        output.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Texture_Sampling">
                                <h3 class="VK_n22">
                                    Texture Sampling
                                </h3>
                                <p>
                                    To get the best performance out of textures and texture operations, consider the
                                    following items:
                                </p>
                                <ul>
                                    <li>
                                        When sampling from a render target, avoid sampling across mip levels of the
                                        surface with instructions such as sample_l/sample_b.
                                    </li>
                                    <li>
                                        Use API defined and architecture supported compression formats (that is,
                                        BC1-BC7) on larger textures to improve memory bandwidth utilization, and improve
                                        memory locality, when performing sampling operations.
                                    </li>
                                    <li>
                                        Avoid dependent texture samples between sample instructions. For example, avoid
                                        making the UV coordinates of the next sample operation dependent upon the
                                        results of the previous sample operation. In this instance, the shader compiler
                                        may not be able to optimize or reorder the instructions, and it may result in a
                                        sampler bottleneck.
                                    </li>
                                    <li>
                                        Avoid redundant and duplicate sampler states within shader code, and use
                                        static/immutable samplers, if possible.
                                    </li>
                                    <li>
                                        Define appropriate resource types for sampling operation and filtering mode. Do
                                        not use volumetric surface as a 2D array.
                                    </li>
                                    <li>
                                        When fetching from an array surface, ensure that the index is uniform across all
                                        single instruction, multiple data (SIMD) lanes.
                                    </li>
                                    <li>
                                        Avoid defining constant data in textures that could be procedurally computed in
                                        the shader, such as gradients.
                                    </li>
                                    <li>
                                        Avoid anisotropic filtering on sRGB texture
                                    </li>
                                    <li>
                                        Sample_d provides gradient per pixels and throughput drops to one-fourth. Prefer
                                        sample_l unless anisotropic filtering is required.
                                    </li>
                                    <li>
                                        When using VRS, anisotropic filtering may not be needed, as pixels in that draw
                                        will be coarser. Non-anisotropic filtering improves sampler throughput.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Constants">
                                <h3 class="VK_n22">
                                    Constants
                                </h3>
                                <p>
                                    When defining shader constants, the following guidelines can help to achieve better
                                    performance:
                                </p>
                                <ul>
                                    <li>
                                        Structure constant buffers to improve cache locality so that memory accesses all
                                        occur on the same cache line to improve memory performance.
                                    </li>
                                    <li>
                                        Favor constant access that uses direct access since the offset is known at
                                        compile time, rather than indirect access, in which the offset must be computed
                                        at runtime. This benefits high latency operations like flow control and
                                        sampling.
                                    </li>
                                    <li>
                                        Group the more frequently used constants for better cache utilization and move
                                        them to the beginning of the buffer.
                                    </li>
                                    <li>
                                        Organize constants by frequency of update, and only upload when the values
                                        change.
                                    </li>
                                    <li>
                                        When loading data from buffers or structured buffers, organize the data access
                                        in a way that all or the majority of the cache line is used. For example, if a
                                        structured buffer has ten attributes, and only one of those attributes is used
                                        for reading and/or writing, it would be better to split that one attribute into
                                        its own structured buffer.
                                    </li>
                                    <li>
                                        Consider using ByteAddressBuffers when performing consecutive data loads instead
                                        of loading data from a Typed Buffer. Those can be optimized by our shader
                                        compiler.
                                    </li>
                                    <li>
                                        On DX11, developers will see the best performance in shaders that avoid sparsely
                                        referencing the constant data in constant buffers. Best performance will also be
                                        achieved if only up to two constant buffers are referenced in non-compute
                                        shaders.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Temporary_Register_Variable_Usage">
                                <h3 class="VK_n22">
                                    Temporary Register Variable Usage
                                </h3>
                                <p>
                                    Each thread on an execution unit has its own set of registers to store values.
                                    Registers can help reduce memory penalties. However, if there are more temporary
                                    variables than registers, some of those variables will have to be stored in memory,
                                    where reading and writing have a latency cost. Avoiding this spillover can help to
                                    improve performance.
                                </p>
                                <p>
                                    On Xe-LP, reducing register pressure not only increases SIMD width, but also betters
                                    code scheduling.
                                </p>
                                <p class="m-0">
                                    When writing shaders, the following help reduce spillover and improve performance:
                                </p>
                                <ul>
                                    <li>
                                        Try to optimize the number of temporaries to 16, or fewer, per shader. This
                                        limits the number of register transfers to and from main memory, which has
                                        higher latency costs. Check the instruction set assembly code output, and look
                                        for spill count. Spills are a good opportunity for optimization as they reduce
                                        the number of operations that depend on high latency memory operations. This can
                                        be done in Intel GPA by selecting a shader and choosing to look at the machine
                                        code generated by the compiler.
                                    </li>
                                    <li>
                                        If possible, move the declaration and assignment of a variable closer to where
                                        it will be referenced.
                                    </li>
                                    <li>
                                        Weigh the options between full and partial precision on variables, as this can
                                        store more values in the same space. Use caution when mixing partial precision
                                        with full precision in the same instruction—it may cause redundant type
                                        conversions.
                                    </li>
                                    <li>
                                        Move redundant code that is common between branches out of the branch. This can
                                        reduce redundant variable duplication.
                                    </li>
                                    <li>
                                        Avoid non-uniform access to constant buffer/buffer data. Non-uniform access
                                        requires more temporary registers to store data per SIMD lane.
                                    </li>
                                    <li>
                                        Avoid control flow decision based on constant buffer data, as this forces the
                                        compiler to generate sub-optimal machine code. Instead, use specialization
                                        constants, or generate multiple specialized shader permutations.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Compute_Shader_Considerations">
                                <h3 class="VK_n22">
                                    Compute Shader Considerations
                                </h3>
                                <p>
                                    When developing compute shaders, the following guidelines can help to achieve
                                    optimal performance when selecting thread group sizes:
                                </p>
                                <ul>
                                    <li>
                                        Pick thread-group sizes and dimensions that fit the nature of your workload’s
                                        memory access patterns. For instance, if your application accesses memory in a
                                        linear fashion, specify a linear dimension thread group size—such as 64 x 1 x 1.
                                    </li>
                                    <li>
                                        For two-dimensional thread groups, smaller thread-group sizes typically lead to
                                        better performance, and achieve better execution unit thread occupancy.
                                    </li>
                                    <li>
                                        Generally, a thread-group size of 8 x 8 performs well on Xe-LP. In some cases,
                                        this may not be optimal due to memory access patterns and/or cache locality. In
                                        this case, dimensions of 16x16 or higher should be experimented with, based on
                                        their performance in testing.
                                    </li>
                                    <li>
                                        Thread-group size higher or equal to 256 threads can cause thread occupancy
                                        issues.
                                    </li>
                                    <li>
                                        Avoid using Atomics on UAVs when possible. However, Atomics on SLM variables do
                                        not show any performance issues.
                                    </li>
                                </ul>
                                <p>
                                    When developing compute shaders that use SLM, consider the following:
                                </p>
                                <ul>
                                    <li>
                                        Minimize the number of reads and writes. For instance, an array of float4 data
                                        should be loaded and stored in one bank of float4 types, rather than four banks
                                        of float arrays.
                                    </li>
                                    <li>
                                        Try to keep variables in registers rather than shared local memory to save on
                                        memory access penalties.
                                    </li>
                                    <li>
                                        Load and store data so that data elements consecutively accessed are located
                                        back-to-back. This allows read and write access to be coalesced, and bandwidth
                                        to be used efficiently.
                                    </li>
                                    <li>
                                        Use HLSL interlocked functions to perform min, max, or, and other reductions,
                                        instead of moving data to and from SLM to perform the same operation with a
                                        user-defined operation. The compiler can map HLSL functions to a
                                        hardware-implemented version.
                                    </li>
                                    <li>
                                        Avoid using more than 73-Byte of SLM per lane, as this will reduce the SIMD
                                        width. Examples:
                                        <ul>
                                            <li>
                                                For 8x8 thread group use less than 4,672-Byte
                                            </li>
                                            <li>
                                                For 16x16 thread group use less than 18,688-Byte
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Wave_Intrinsics">
                                <h3 class="VK_n22">
                                    Wave Intrinsics
                                </h3>
                                <p>
                                    Xe-LP supports the use of wave intrinsics for both 3D and compute workloads. These
                                    can be used to write more efficient register-based reductions, and to reduce
                                    reliance on global or local memory for communication across lanes. Threads within
                                    the thread group can share information without the use of barriers, and other cross
                                    lane operations for threads are enabled in the same wave. While working with wave
                                    intrinsics on Gen11, consider the following:
                                </p>
                                <ul>
                                    <li>
                                        Do not write shaders that assume a specific machine width. Wave width can vary
                                        across shaders from SIMD8, SIMD16, and SIMD32, and is chosen by heuristics in
                                        the shader compiler. Because of this, use instructions such as
                                        WaveGetLaneCount() in algorithms that depend on wave size.
                                    </li>
                                    <li>
                                        Wave operations can be used to reduce memory bandwidth by enabling access to
                                        data already stored in registers by other threads, instead of storing and
                                        re-loading results from memory. It is a great fit for optimizing operations such
                                        as texture mipmap generation.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Frame_presentation">
                                <h3 class="VK_n22">
                                    Frame Presentation
                                </h3>
                                <p>
                                    For the best performance and compatibility across different Windows versions, it is
                                    recommended to use full-screen presentation modes if possible. Other modes require
                                    an extra context switch and full screen copy. On Windows 10, it is possible to use
                                    full-screen borderless windowed modes with no penalty and no performance loss to the
                                    Desktop Window Manager. In doubt, use tools such as
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        PresentMon
                                    </a>
                                    to know which presentation mode is active, and GPUView (part of the Windows® 10 SDK)
                                    for possible intervention by the Desktop Window Manager.
                                </p>
                                <p>
                                    Ensure that PresentMon reports “Hardware Composed: Independent Flip” and that no
                                    activity is reported by DWM.exe in your ETW trace.
                                </p>
                                <div class="d-flex justify-content-center">
                                    <div class="col-sm-9">
                                        <img src="/img/vivek/VK_102.png" class="w-100" alt="">
                                    </div>
                                </div>
                            </section>
                            <section class="mt-4" id="VK_Dual_Queue_Support">
                                <h3 class="VK_n22">
                                    Dual Queue Support
                                </h3>
                                <p>
                                    Xe-LP supports the use of dual queues, which can concurrently have 3D and compute
                                    workloads resident in the threads of each sub-slice. When sharing resources across
                                    queues, use COMMON state transitions when possible.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_CPU_performance_considerations">
                                <h3 class="VK_n22">
                                    CPU performance considerations
                                </h3>
                                <ul>
                                    <li>
                                        The DX11 driver utilizes threading to perform work parallelization. Fully
                                        subscribing all available CPU hardware threads with application work can result
                                        in starvation of these helper threads, and significantly reduce performance.
                                        Query the available hardware threads on the system your application is running
                                        on, and leave the better portion of one hardware thread free for the driver to
                                        parallelize work.
                                    </li>
                                    <li>
                                        The DX12 driver relies heavily on
                                        <a href="" class="Vk_text_underline_dots VK_a">
                                            background shader optimizations
                                        </a>
                                        Do NOT disable this thread. If you do, it will significantly increase loading
                                        times—and can also reduce GPU performance as these optimizations can no longer
                                        be performed. Also, ensure you leave at least one CPU hardware thread available
                                        to perform this work—do not fully subscribe every available hardware thread on
                                        the CPU with application work.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Design_Low_Power">
                                <h3 class="VK_n22 fw-light">
                                    Design for Low Power
                                </h3>
                                <p>
                                    Mobile and ultra-mobile computing are ubiquitous. On these platforms, power is
                                    shared between CPU and GPU, so optimizing for CPU can frequently result in GPU
                                    performance gains. As a result, battery life, device temperature, and power-limited
                                    performance have become significant issues. As manufacturing processes continue to
                                    shrink and improve, we see improved performance per-watt characteristics of CPUs and
                                    processor graphics. However, there are many ways that software can reduce power use
                                    on mobile devices, as well as improve power efficiency. In the following sections,
                                    you will find insights and recommendations illustrating how to best recognize these
                                    performance gains.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_Idle_Active_Power">
                                <h3 class="VK_n22">
                                    Idle and Active Power
                                </h3>
                                <p>
                                    Processors execute in different power states, known as P-states and C-states.
                                    C-states are essentially idle states that minimize power draw by progressively
                                    shutting down more and more of the processor. P-states are performance states where
                                    the processor consumes progressively more power and runs faster at a higher
                                    frequency.
                                </p>
                                <p>
                                    These power states define how much time the processor is sleeping and how it
                                    distributes available power when active. Power states can change very quickly, so
                                    sleep states are relevant to most applications that do not consume all the power
                                    available, including real-time applications.
                                </p>
                                <p>
                                    When you optimize applications, try to save power in two different ways:
                                </p>
                                <ul>
                                    <li>
                                        Increase the amount of idle time your application uses where it makes sense.
                                    </li>
                                    <li>
                                        Improve overall power usage and balance under active use.
                                    </li>
                                </ul>
                                <p>
                                    You can determine the power state behavior of your application by measuring how much
                                    time it spends in each state. Since each state consumes a different amount of power,
                                    you will get a picture over time of your app’s overall power use.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_Analysis_Tips">
                                <h3 class="VK_n22 mb-3">
                                    Analysis Tips
                                </h3>
                                <p class="m-0">
                                    To start, begin by measuring your app’s baseline power usage in multiple cases and
                                    at different loads:
                                </p>
                                <ul>
                                    <li>
                                        At near idle, as in the user interface (UI) during videos
                                    </li>
                                    <li>
                                        Under an average load during a typical scene with average effects
                                    </li>
                                </ul>
                                <p class="M-0">
                                    The worst-case load may not occur where you expect it to. We have seen very high
                                    frame rates [1,000 frames per second (fps)] during cut-scene video playback in
                                    certain apps, a situation that can cause the GPU and CPU to use unnecessary power.
                                    As you study your application, try a few of these tips:
                                </p>
                                <ul>
                                    <li>
                                        Measure how long (on average) your application can run on battery power, and
                                        compare its performance with other, similar apps. Measuring power consumption
                                        regularly informs you if any recent changes caused your app to use more power
                                    </li>
                                    <li>
                                        The Battery Life Analyzer (BLA) is a good (Windows-only) tool for this work, as
                                        it can collect high-level data and analyze an app's power use. If the data that
                                        BLA provides shows that you have issues residing in the wrong C-states for too
                                        long, it is time to look deeper.
                                    </li>
                                    <li>If your app is reported as deficient or there are unexpected wakeups, start
                                        optimizing for power. To do so, you will want to look at the Windows Performance
                                        Analyzer (WPA) tool, which showcases workflow using WPA for CPU analysis.
                                    </li>
                                    <li>
                                        Intel® VTune™ Profiler XE is also useful to get power call stacks, since it can
                                        identify the cause of the wakeup.
                                    </li>
                                </ul>
                                <p>
                                    Use the data gained through these methods to reduce or consolidate wakeups, thus
                                    remaining in a lower power state longer.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_Investigating_Idle_Power">
                                <h3 class="VK_n22">
                                    Investigating Idle Power
                                </h3>
                                <p>
                                    As you study power at near idle, watch for very high frame-rates.
                                </p>
                                <p>
                                    If your app has high frame-rates at near idle power (during cut scenes, menus, or
                                    other low-GPU intensive parts), remember that these parts of your app will look fine
                                    if you lock the present interval to a 60 Hz display refresh rate (or clamp your
                                    frame rate lower, to 30 fps).
                                </p>
                                <p>
                                    Watch for these behaviors in menus, loading screens, and other low-GPU intensive
                                    parts of games, and scale accordingly to minimize power consumption. This can also
                                    improve CPU intensive loading times, by allowing turbo boost to kick in, when
                                    necessary.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_Active_Power_Speed_Shift">
                                <h3 class="VK_n22">
                                    Active Power and Speed Shift
                                </h3>
                                <p>
                                    While in active states, the processor and the operating system jointly decide
                                    frequencies for various parts of the system (CPUs, GPU, and memory ring, in
                                    particular). The current generation of Intel Core processors add more interaction
                                    between the operating system and the processor(s) to respond more efficiently and
                                    quickly to changes in power demand—a process referred to as Intel® Speed Shift
                                    Technology.
                                </p>
                                <p>
                                    The system balances the frequencies based on activity and increases frequency (and
                                    thus consumed power) where it is needed most. As a result, a mostly active workload
                                    may have its GPU and CPU balance frequencies based on power consumption.
                                </p>
                                <p>
                                    Reducing the amount of work done on the CPU can free up power for the GPU and vice
                                    versa. This can result in better overall performance, even when the other side was
                                    the primary performance bottleneck.
                                </p>
                                <p>
                                    Tools such as
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Intel® Power Gadget
                                    </a>
                                    can also help you see the frequencies of each clock domain in real time. You can
                                    monitor the frequencies of different subsystems on target devices by running this
                                    tool.
                                </p>
                                <p>
                                    You can tell that your app’s power distribution is getting balanced when the primary
                                    performance bottleneck is not running at full frequency, but power consumption is
                                    reaching the maximum limits available.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_When_Reduce_Activity">
                                <h3 class="VK_n22">
                                    When and How to Reduce Activity
                                </h3>
                                <p>
                                    There are times when the user explicitly requests trading performance for battery
                                    life, and there are things you can do to more effectively meet these demands. There
                                    are also patterns in application usage that always consume extra power for little
                                    return, patterns that you can more effectively address to handle overall power
                                    usage. In the next sections you will see some issues to watch for when trying to
                                    reduce overall power consumption.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_Scale_Settings_Match_System_Power_Settings_Power_Profile">
                                <h3 class="VK_n22">
                                    Scale Settings to Match System Power Settings and Power Profile
                                </h3>
                                <p class="m-0">
                                    It was once necessary to poll for power settings and profile (for example,
                                    GetSystemPowerStatus()), but since the launch of Windows® Vista, Windows® supports
                                    asynchronous power notification APIs.
                                </p>
                                <ul>
                                    <li>
                                        Use RegisterPowerSettingNotification() with the appropriate globally unique
                                        identifier (GUID) to track changes.
                                    </li>
                                    <li>
                                        Scale your app's settings and behavior based on the power profile and whether
                                        your device is plugged in to power. Scale the resolution, reduce the max frame
                                        rate to a cap, and/or reduce quality settings.
                                    </li>
                                    <li>
                                        If you cap the frame rate, you can use V-Sync. You can also manage the frame
                                        rate and resolution yourself as well. The
                                        <a href="" class="Vk_text_underline_dots VK_a">
                                            dynamic resolution rendering (DRR) sample
                                        </a>
                                        shows how to adjust frame resolution to maintain a frame rate.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Run_Slow_Remaining_Responsive">
                                <h3 class="VK_n22">
                                    Run as Slow as You Can While Remaining Responsive
                                </h3>
                                <p class="m-0">
                                    If you run as slow as you can (but still remain responsive) then you can save power
                                    and extend battery life.
                                </p>
                                <ul>
                                    <li>
                                        Detect when you are in a power-managed mode and limit frame rate. This prolongs
                                        battery life and allows your system to run cooler. Running at 30 Hz instead of
                                        60 Hz can save significant power.
                                    </li>
                                    <li>
                                        Provide a way to disable the frame rate limit, for benchmarking. Warn players
                                        that they will use their battery quickly. You should also want to let the player
                                        control the frame rate cap.
                                    </li>
                                    <li>
                                        Use off-screen buffers and do smart compositing for in-game user interfaces
                                        (which are often limited to small panels for displays like health, power-ups,
                                        and so on). Since user interfaces usually change much more slowly than in-game
                                        scenes, there is no need to change them at the same rate as the game frame. Here
                                        again, DRR may be useful in helping you decouple UI rendering from main scene
                                        rendering.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Manage_Timers_Respect_System_Idle_Avoid_Tight_Polling_Loops">
                                <h3 class="VK_n22">
                                    Manage Timers and Respect System Idle, Avoid Tight Polling Loops
                                </h3>
                                <p class="m-0">
                                    There are several other related points to watch:
                                </p>
                                <ul>
                                    <li>
                                        Reduce your app's reliance on high-resolution periodic timers.
                                    </li>
                                    <li>
                                        Avoid Sleep() calls in tight loops. Use Wait*() APIs instead. Sleep() or any
                                        other busy-wait API can cause the operating system to keep the machine from
                                        being in the Idle state.
                                        <a href="" class="Vk_text_underline_dots VK_a">
                                            Intel® Mobile Platform Idle Optimization
                                        </a>
                                        presentation offers an extensive rundown of which APIs to use and to avoid.
                                    </li>
                                    <li>
                                        Avoid tight polling loops. If you have a polling architecture that uses a tight
                                        loop, convert it to an event-driven architecture. If you must poll, use the
                                        largest polling interval possible.
                                    </li>
                                    <li>
                                        Avoid busy-wait calls. This can cause unnecessary power use. There is no way for
                                        the operating system, or the power management hardware, to detect that the code
                                        does nothing useful.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Multithread_Sensibility">
                                <h3 class="VK_n22">
                                    Multithread Sensibility
                                </h3>
                                <p>
                                    Balanced threading offers performance benefits, but you need to consider how it
                                    operates alongside the GPU, as imbalanced threading can also result in lower
                                    performance and reduced power efficiency. Avoid affinitizing threads so that the
                                    operating system can schedule threads directly. If you must, provide hints using
                                    SetIdealProcessor().
                                </p>
                            </section>
                            <section class="mt-4" id="VK_Using_CPU_SIMD">
                                <h3 class="VK_n22">
                                    Using CPU SIMD
                                </h3>
                                <p>
                                    Using CPU SIMD instructions, either through the
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Intel® SPMD Program Compiler
                                    </a>
                                    (Intel® ISPC) or C++ intrinsics, can provide a significant power and performance
                                    boost. These improvements can be even bigger by using the latest instruction set.
                                </p>
                                <p>
                                    However, on processors prior to Intel® 10th generation Core™ (Codename Icelake),
                                    using AVX2 and particularly AVX512 SIMD instruction requires a voltage increase in
                                    order to power the SIMD architecture block. In order to avoid power increase, Intel
                                    Core processors will run at a lower frequency, which can decrease performance for a
                                    mostly scalar workload with a few SIMD instructions. For this reason, sporadic
                                    AVX512 SIMD usage should be avoided on these older processors.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_Power_Versus_Frame_Rate">
                                <h3 class="VK_n22">
                                    Power Versus Frame Rate
                                </h3>
                                <p>
                                    The latest graphics APIs (DirectX 12, Vulkan, and Metal 2) can dramatically reduce
                                    CPU overhead, resulting in lower CPU power consumption given a fixed frame rate (33
                                    fps), as shown on the left side in the figure below. When unconstrained by frame
                                    rate the total power consumption is unchanged, but there is a significant
                                    performance boost due to increased GPU utilization. See the
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Asteroids* and DirectX* 12
                                    </a>
                                    white paper for full details.
                                </p>
                                <div class="d-flex justify-content-center">
                                    <div class="col-md-9">
                                        <img src="/img/vivek/VK_103.png" class="w-100" alt="">
                                        <p class="mt-2 text-center">
                                            Asteroids* Demo-Power versus Frame Rate
                                        </p>
                                    </div>
                                </div>
                            </section>
                            <section class="mt-3" id="VK_Additional_Resources_Intel_Developer_Zone_Game_Dev_Websites">
                                <h3 class="VK_side_heading fw-light">
                                    Additional Resources on Intel® Developer Zone and Game Dev Websites
                                </h3>
                            </section>
                            <section class="mt-3" id="VK_Intel_Software_Developer_Zone_Game_Dev_Websites">
                                <h3 class="VK_n22">
                                    Intel® Software Developer Zone and Game Dev Websites
                                </h3>
                                <p>
                                    Intel® regularly releases code samples covering a variety of topics to the developer
                                    community. For the most up-to-date samples and links, see the following resources:
                                </p>
                                <p>
                                    <a href="" class="VK_a">
                                        Intel® Software Developer Zone Code Samples
                                    </a>
                                    <br>
                                    <br>
                                    <a href="" class="VK_a">
                                        GitHub* Intel Repository
                                    </a>
                                    <br><br>
                                    <a href="" class="VK_a">
                                        Intel XeSS Code Samples
                                    </a>
                                </p>
                                <p>
                                    Following are descriptions and links to samples that may also be of interest to
                                    developers targeting current Intel® systems.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_Dynamic_Resolution_Rendering">
                                <h3 class="VK_n22 mb-4">
                                    Dynamic Resolution Rendering
                                </h3>
                                <p>
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        DRR
                                    </a>
                                    is an algorithm that aims to increase and smoothen game performance by trying to
                                    keep a fixed displayed render target resolution, but dynamically varies the
                                    resolution that is driving the engine shading.
                                </p>
                                <p>
                                    One of the primary issues inhibiting adoption of DRR is the modification to
                                    post-processing pipelines that it requires. With the introduction of DirectX 12 and
                                    placed resources we are introducing an updated algorithm implementation that removes
                                    the need for most, if not all, post-processing pipeline modifications at the cost of
                                    increasing your memory requirements with an additional dynamic resolution render
                                    target buffer.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_Checkerboard_Rendering">
                                <h3 class="VK_side_heading">
                                    Checkerboard Rendering
                                </h3>
                                <p>
                                    While some graphics optimizations focus on reducing geometric level of detail,
                                    checkerboard rendering (CBR) reduces the amount of shading done that is
                                    imperceptible. The technique produces full resolution pixels that are compatible
                                    with modern post processing techniques and can be implemented for both forward and
                                    deferred rendering. More information, implementation details, and sample code can be
                                    found in the white paper Checkerboard Rendering for Real-Time Upscaling on Intel
                                    Integrated Graphics.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_Conservative_Morphological_AntiAliasing">
                                <h3 class="VK_n22">
                                    Conservative Morphological Anti-Aliasing 2.0
                                </h3>
                                <p>
                                    Conservative Morphological Anti-Aliasing 2.0 (CMAA-2) is an update to the
                                    image-based conservative morphological anti-aliasing algorithm. This implementation
                                    provides improvements to the anti-aliasing quality and performance of previous
                                    implementations. For more information, refer to the
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Conservative Morphological Anti-Aliasing 2.0
                                    </a>
                                    white paper.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_Adaptive_Screen_Space_Ambient_Occlusion">
                                <h3 class="VK_n22">
                                    Adaptive Screen Space Ambient Occlusion
                                </h3>
                                <p>
                                    Screen space ambient occlusion (SSAO) is a popular effect used in real-time
                                    rendering
                                    to produce small-scale ambient effects and contact shadow effects. It is used by
                                    many modern game engines, typically using 5 to 10 percent of the frame GPU time.
                                    Although several public implementations already exist, not all are open source or
                                    freely available, or provide the level of performance scaling required for both
                                    low-power mobile and desktop devices. This is where Adaptive Screen Space Ambient
                                    Occlusion (ASSAO) fills needed gaps. ASSAO is specially designed to scale from
                                    low-power devices and scenarios up to high-end desktops at high resolutions, all
                                    under one implementation with a uniform look, settings, and quality that is equal to
                                    the industry standard. For more information, refer to the white paper
                                    <a href="" class="VK_a Vk_text_underline_dots">
                                        Adaptive Screen Space Ambient Occlusion.
                                    </a>
                                </p>
                            </section>
                            <section class="mt-4" id="VK_GPU_Detect">
                                <h3 class="VK_n22">
                                    GPU Detect
                                </h3>
                                <p>
                                    The GPU Detect sample demonstrates how to get the vendor and ID from the GPU. For
                                    Intel® Processor Graphics, the sample also demonstrates a default graphics quality
                                    preset (low, medium, or high), support for DirectX 9 and DirectX 11 extensions, and
                                    the recommended method for querying the amount of video memory. If supported by the
                                    hardware and driver, it also shows the recommended method for querying the minimum
                                    and maximum frequencies.
                                </p>
                                <P>
                                    The sample uses a configuration file that lists many of the Intel® Processor
                                    Graphics by vendor ID and device ID, along with a suggested graphics quality level
                                    for each device. To maximize performance, you should test some representative
                                    devices with your application and decide which quality level is right for each. Be
                                    careful with relying only on device ID, as a platform’s performance also depends
                                    heavily on the available power, which can be set by the device manufacturer to
                                    something lower than the optimal thermal design point.
                                </P>
                            </section>
                            <section class="mt-4" id="VK_Fast_ISPC_Texture_Compression">
                                <h3 class="VK_n22">
                                    Fast ISPC Texture Compression
                                </h3>
                                <p>
                                    The
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Fast ISPC Texture Compressor sample
                                    </a>
                                    performs high-quality BC7, BC6H, ETC1, and ASTC compression on the CPU using the
                                    ISPC to exploit SIMD instruction sets.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_Additional_Resources">
                                <h3 class="VK_n22 mb-4">
                                    Additional Resources
                                </h3>
                                <p>
                                    <a href="" class="VK_a">
                                        Hybrid optimization guidance
                                    </a>
                                    - Game Dev Guide for 12th Gen Intel® Core™ Processor
                                </p>
                                <p>
                                    <a href="" class="VK_a">
                                        Direct3D* Website
                                    </a>
                                    - DirectX 12 and other DirectX resources
                                </p>
                                <p>
                                    <a href="" class="VK_a">
                                        Vulkan*
                                    </a>
                                    - Khronos site with additional resources
                                </p>
                                <p>
                                    <a href="" class="VK_a">
                                        Metal 2
                                    </a>
                                    - Apple’s developer site for Metal 2
                                </p>
                            </section>
                            <section class="mt-2" id="VK_Revision_History">
                                <h3 class="VK_n22">
                                    Revision History
                                </h3>
                                <div>
                                    <table>
                                        <tbody class="">
                                            <tr>
                                                <td class="VK_start_border p-3">
                                                    Original Release
                                                </td>
                                                <td class="VK_start_border p-3">
                                                    June 2021
                                                </td>
                                            </tr>
                                            <tr>
                                                <td class="VK_start_border VK_theme_bg p-3">
                                                    Update
                                                </td>
                                                <td class="VK_start_border VK_theme_bg p-3">
                                                    March 2023
                                                </td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </section>
                            <section class="mt-2" id="VK_Notices">
                                <h3 class="VK_n22">
                                    Notices
                                </h3>
                                <p>
                                    Intel technologies’ features and benefits depend on system configuration and may
                                    require enabled hardware, software or service activation. Performance varies
                                    depending on system configuration. Check with your system manufacturer or retailer
                                    or learn more at intel.com.
                                </p>
                                <p>
                                    No license (express or implied, by estoppel or otherwise) to any intellectual
                                    property rights is granted by this document.
                                </p>
                                <p>
                                    Intel disclaims all express and implied warranties, including without limitation,
                                    the implied warranties of merchantability, fitness for a particular purpose, and
                                    non-infringement, as well as any warranty arising from course of performance, course
                                    of dealing, or usage in trade.
                                </p>
                                <p>
                                    This document contains information on products, services and/or processes in
                                    development. All information provided here is subject to change without notice.
                                    Contact your Intel representative to obtain the latest forecast, schedule,
                                    specifications and roadmaps.
                                </p>
                                <p>
                                    The products and services described may contain defects or errors known as errata
                                    which may cause deviations from published specifications. Current characterized
                                    errata are available on request.
                                </p>
                                <p>
                                    Copies of documents which have an order number and are referenced in this document
                                    may be obtained by calling 1-800-548-4725 or by visiting
                                    www.intel.com/design/literature.htm.
                                </p>
                                <p>
                                    Intel, the Intel logo, Intel Core, and VTune are trademarks of Intel Corporation in
                                    the U.S. and/or other countries.
                                </p>
                                <p>
                                    Microsoft, Windows, and the Windows logo are trademarks, or registered trademarks of
                                    Microsoft Corporation in the United States and/or other countries.
                                </p>
                                <p>
                                    *Other names and brands may be claimed as the property of others.
                                </p>
                                <p>
                                    © 2023 Intel Corporation
                                </p>
                            </section>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!--  -->
        <section class="py-5">
            <div class="VK_cont">
                <div class="row m-0">
                    <div class="col">
                        <p class="mb-2">
                            Product and Performance Information
                        </p>
                        <p class="VK_font14">
                            Performance varies by use, configuration and other factors. Learn more at
                            <a href="" class="Vk_text_underline_dots VK_a">
                                www.Intel.com/PerformanceIndex.
                            </a>
                        </p>
                    </div>
                </div>
            </div>
        </section>


        <!-- footer -->
        <footer>
            <div id="footer"></div>
        </footer>

    </main>

    <!---------------- Javascript Files ---------------->

    <script>
        // navbar include
        fetch('/y_index/y_navbar.html')
            .then(response => response.text())
            .then(data => {
                document.getElementById('navbar').innerHTML = data;
            });
        // footer include 
        fetch('/y_index/y_footer.html')
            .then(response => response.text())
            .then(data => {
                document.getElementById('footer').innerHTML = data;
            });
    </script>

    <!-- jquery -->
    <!-- <script src="/js/jquery-3.7.1.js"></script> -->


    <!-- bootstrap js file -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>

    <!-- costom js file -->
    <script src="/js/vivek.js"></script>

    <!-- all min -->
    <script src="/js/all.min.js"></script>

</body>

</html>