<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <!-- font family -->
    <link href="https://fonts.cdnfonts.com/css/intel-clear" rel="stylesheet">
    <!-- boootstap file -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <!-- costom css file -->
    <link rel="stylesheet" href="/css/vivek.css">
    <link rel="stylesheet" href="/css/yatri.css">

    <!-- all.min file -->
    <link rel="stylesheet" href="/css/all.min.css">

</head>

<body>

    <main>

        <!-- header -->
        <header>
            <div id="navbar"></div>
        </header>


        <!-- poster -->
        <section class=" VK_light_blue">
            <div class="VK_cont">
                <div class="row m-0">
                    <div class="col text-white">
                        <h1 class="VK_py_pre_heading fw-light m-0 py-4 mt-2">
                            Intel® Arc™ A-series Graphics Gaming API Developer and Optimization Guide
                        </h1>
                        <div
                            class="d-flex pb-4 col-md-4 col-sm-6 col-12 flex-md-row flex-column justify-content-between">
                            <div class="d-flex flex-md-column flex-row">
                                <p class="mb-2 me-3 w-100">
                                    ID
                                </p>
                                <p class="mb-2 me-3 w-100">
                                    737258
                                </p>
                            </div>
                            <div class="d-flex flex-md-column flex-row">
                                <p class="mb-2 me-3 w-100">
                                    Updated
                                </p>
                                <p class="mb-2 me-3 w-100">
                                    6/20/2022
                                </p>
                            </div>
                            <div class="d-flex flex-md-column flex-row">
                                <p class="mb-2 me-3 w-100">
                                    Version
                                </p>
                                <p class="mb-2 me-3 w-100">
                                    Latest
                                </p>
                            </div>
                            <div class="d-flex flex-md-column flex-row">
                                <p class="mb-2 me-3 d-none d-md-block">
                                    &nbsp;
                                </p>
                                <p class="mb-2 me-3 w-100">
                                    Public
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!--  -->
        <section class="">
            <div class="VK_cont py-5 VK_border_bottom">
                <div class="row m-0">
                    <div class="col-md-4 col-lg-3 d-md-block d-none">
                        <div class="VK_sticky_side_bar VK_side_bar_postion_stickey">
                            <div>
                                <div class="VK_sidebar_dropdown">
                                    <details>
                                        <summary>
                                            <a href="#VK_HPG_features_highlights" class="text-decoration-none VK_a">
                                                Xe-HPG Features Highlights
                                            </a>
                                        </summary>
                                        <ul class="list-unstyled ps-3">
                                            <li>
                                                <a href="#VK_DirectX_ultimate_support"
                                                    class="text-decoration-none VK_a my-1">
                                                    DirectX 12 Ultimate* Support
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_hardware_ray_tracing_support"
                                                    class="text-decoration-none VK_a my-1">
                                                    Hardware Ray-Tracing Support
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_variable_rate_shading"
                                                    class="text-decoration-none VK_a my-1">
                                                    Variable-Rate Shading
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_mesh_shading" class="text-decoration-none VK_a my-1">
                                                    Mesh Shading
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_directX_view_instancing_vulkan_multiview"
                                                    class="text-decoration-none VK_a my-1">
                                                    DirectX* 12 View Instancing and Vulkan* Multiview
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_directX_sampler_feedback"
                                                    class="text-decoration-none VK_a my-1">
                                                    DirectX 12 Sampler Feedback
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_DirectStorage" class="text-decoration-none VK_a my-1">
                                                    DirectStorage
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_high_dynamic_range_displays"
                                                    class="text-decoration-none VK_a my-1">
                                                    High Dynamic Range Displays
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_adaptive_sync_variable_refresh_rate"
                                                    class="text-decoration-none VK_a my-1">
                                                    Adaptive-Sync—Variable Refresh Rate
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_other_API_feature_support"
                                                    class="text-decoration-none VK_a my-1">
                                                    Other API Feature Support
                                                </a>
                                            </li>
                                        </ul>
                                    </details>
                                    <p class="m-0">
                                        <a href="#VK_tools_for_performance_analysis" class="text-decoration-none VK_a">
                                            Tools for Performance Analysis
                                        </a>
                                    </p>
                                    <p class="m-0">
                                        <a href="#VK_performance_recommendations_for_Intel_graphics_processors"
                                            class="text-decoration-none VK_a">
                                            Performance Recommendations for Intel Xe-HPG Graphics Processors
                                        </a>
                                    </p>
                                    <details>
                                        <summary>
                                            <a href="#VK_GPU_detection_for_features" class="text-decoration-none VK_a">
                                                GPU Detection for Features
                                            </a>
                                        </summary>
                                        <ul class="list-unstyled ps-3">
                                            <li>
                                                <a href="#VK_additional_notes" class="text-decoration-none VK_a my-1">
                                                    Additional Notes
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_configuring_graphics_pipeline_state"
                                                    class="text-decoration-none VK_a my-1">
                                                    Configuring Graphics Pipeline State
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_resource_binding" class="text-decoration-none VK_a my-1">
                                                    Resource Binding
                                                </a>
                                            </li>
                                            <li>
                                                <details>
                                                    <summary>
                                                        <a href="#VK_render_targets_and_textures"
                                                            class="text-decoration-none VK_a">
                                                            Render Targets and Textures
                                                        </a>
                                                    </summary>
                                                    <ul class="list-unstyled ps-3">
                                                        <li>
                                                            <a href="#VK_general_guidance"
                                                                class="text-decoration-none VK_a">
                                                                General Guidance
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_UAVs_and_SSBOs"
                                                                class="text-decoration-none VK_a">
                                                                UAVs and SSBOs
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_Anti_Aliasing"
                                                                class="text-decoration-none VK_a">
                                                                Anti-Aliasing
                                                            </a>
                                                        </li>
                                                    </ul>
                                                </details>
                                            </li>
                                            <li>
                                                <a href="#VK_resource_barriers" class="text-decoration-none VK_a my-1">
                                                    Resource Barriers
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_command_submissions"
                                                    class="text-decoration-none VK_a my-1">
                                                    Command Submissions
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Optimizing_Clear_Copy_and_Update_Operations"
                                                    class="text-decoration-none VK_a my-1">
                                                    Optimizing Clear, Copy, and Update Operations
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Geometry_Transformation"
                                                    class="text-decoration-none VK_a my-1">
                                                    Geometry Transformation
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_shader_Optimizations"
                                                    class="text-decoration-none VK_a my-1">
                                                    Shader Optimizations
                                                </a>
                                            </li>
                                            <li>
                                                <details>
                                                    <summary>
                                                        <a href="#VK_General_Shader_Guidance"
                                                            class="text-decoration-none VK_a">
                                                            General Shader Guidance
                                                        </a>
                                                    </summary>
                                                    <ul class="list-unstyled ps-3">
                                                        <li>
                                                            <a href="#VK_Texture_Sampling"
                                                                class="text-decoration-none VK_a">
                                                                Texture Sampling
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_Constants" class="text-decoration-none VK_a">
                                                                Constants
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_Temporary_Register_Variable_Usage"
                                                                class="text-decoration-none VK_a">
                                                                Temporary Register Variable Usage
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_Compute_Shader_Considerations"
                                                                class="text-decoration-none VK_a">
                                                                Compute Shader Considerations
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a href="#VK_Wave_Intrinsics"
                                                                class="text-decoration-none VK_a">
                                                                Wave Intrinsics
                                                            </a>
                                                        </li>
                                                    </ul>
                                                </details>
                                            </li>
                                            <li>
                                                <a href="#VK_Frame_Presentation" class="text-decoration-none VK_a my-1">
                                                    Frame Presentation
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_MultiQueue_Support_Recommendations"
                                                    class="text-decoration-none VK_a my-1">
                                                    Multi-Queue Support Recommendations
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_CPU_Performance_Considerations"
                                                    class="text-decoration-none VK_a my-1">
                                                    CPU Performance Considerations
                                                </a>
                                            </li>
                                        </ul>
                                    </details>
                                    <details>
                                        <summary>
                                            <a href="#VK_Additional_Resources" class="text-decoration-none VK_a">
                                                Additional Resources
                                            </a>
                                        </summary>
                                        <ul class="list-unstyled ps-3">
                                            <li>
                                                <a href="#VK_Software_and_Samples" class="text-decoration-none VK_a">
                                                    Software and Samples
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Tools" class="text-decoration-none VK_a">
                                                    Tools
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#VK_Graphics_API" class="text-decoration-none VK_a">
                                                    Graphics API
                                                </a>
                                            </li>
                                        </ul>
                                    </details>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-12 col-md-8 col-lg-7">
                        <div class="VK_all_sections">
                            <div class="VK_section_descriptions">
                                <div class="text-end">
                                    <p class="m-0 VK_print_email_font">
                                        <span class="VK_a mx-2 d-inline-block">
                                            <i class="fa-solid fa-print"></i>
                                        </span>
                                        <span class="VK_a mx-2 d-inline-block">
                                            <i class="fa-regular fa-envelope"></i>
                                        </span>
                                    </p>
                                </div>
                            </div>
                            <div class="mt-5">
                                <p>
                                    The new Intel® Arc™ A-series discrete graphics (formerly code named Alchemist)
                                    implements the Xe-HPG microarchitecture (high-performance graphics) and hosts
                                    multiple
                                    advancements of interest to developers. To gain peak performance, software must
                                    account
                                    for the new architecture and developers must make the right choices regarding APIs.
                                    This
                                    document contains developer guidance and optimization methods, as well as best
                                    practices, to most effectively harness the architecture’s capabilities and achieve
                                    peak
                                    performance.
                                </p>
                            </div>
                            <section class="mt-4" id="VK_HPG_features_highlights">
                                <h3 class="VK_side_heading fw-light">
                                    Xe-HPG Features Highlights
                                </h3>
                                <p>
                                    Xe-HPG offers updates and enhancements to features such as Microsoft DirectX* 12
                                    Ultimate, high-dynamic range (HDR) support, Adaptive-Sync, and DirectStorage.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_DirectX_ultimate_support">
                                <h3 class="VK_side_heading">
                                    DirectX 12 Ultimate* Support
                                </h3>
                                <p>
                                    Xe-HPG will support features available with DirectX 12 Ultimate*, such as:
                                </p>
                                <ul>
                                    <li>
                                        Ray Tracing
                                    </li>
                                    <li>
                                        Mesh Shading
                                    </li>
                                    <li>
                                        Variable Rate Shading (VRS) Tier 2
                                    </li>
                                    <li>
                                        Sampler Feedback
                                    </li>
                                </ul>
                                <p>
                                    To take advantage of DirectX 12 Ultimate, applications must support feature
                                    level
                                    12_2.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_hardware_ray_tracing_support">
                                <h3 class="VK_side_heading">
                                    Hardware Ray-Tracing Support
                                </h3>
                                <p>
                                    Xe-HPG supports hardware accelerated ray tracing in both DirectX 12 (1.0 and
                                    1.1)
                                    and Vulkan* (Vulkan RT). Ray tracing is a technique that can be used to simulate
                                    physical light behavior in 3D applications. It can be used to enable global
                                    illumination, realistic shadows, reflections, ambient occlusion, and other
                                    techniques. A separate guide dedicated to optimizations and best practices for
                                    our
                                    hardware ray-tracing support will be published to the Intel® Developer Zone.
                                </p>
                                <p>
                                    For Vulkan, ray tracing is supported on Xe-HPG through the following Khronos*
                                    extensions:
                                </p>
                                <ul>
                                    <li>
                                        VK_KHR_ray_tracing_pipeline
                                    </li>
                                    <li>
                                        VK_KHR_acceleration_structure
                                    </li>
                                    <li>
                                        VK_KHR_ray_query
                                    </li>
                                    <li>
                                        VK_KHR_pipeline_library
                                    </li>
                                    <li>
                                        VK_KHR_deferred_host_pipeline
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_variable_rate_shading">
                                <h3 class="VK_side_heading">
                                    Variable-Rate Shading
                                </h3>
                                <p>
                                    Variable-rate shading (VRS) gives programmers the ability to vary the shading
                                    rate
                                    independent from the render target resolution and rasterization rate. Among
                                    other
                                    use cases, this feature allows developers to reduce the number of pixel shader
                                    invocations for content that has slowly varying shading parameters, or for
                                    pixels
                                    that may be blurred later in the rendering pipeline. The feature enables
                                    developers
                                    to direct shader resources to the pixels that matter most in their content. This
                                    can
                                    provide a better visual solution than rendering at a lower resolution and then
                                    upscaling, since it preserves the depth and stencil at full pixel rate. Xe-HPG
                                    hardware supports VRS via DirectX 12 Tier 2, and via the
                                    VK_KHR_fragment_shading_rate extension for Vulkan. For more information on
                                    enabling
                                    VRS Tier 1 in your application, refer to the white papers Getting Started with
                                    Variable-Rate Shading on Intel® Processor Graphics and Velocity and Luminance
                                    Adaptive Rasterization Using VRS Tier 2.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_mesh_shading">
                                <h3 class="VK_side_heading">
                                    Mesh Shading
                                </h3>
                                <p>
                                    Mesh shading is a new technique that can replace the traditional geometry
                                    pipelines. For instance, the input assembly, vertex shader, hull shader, domain
                                    shader, tessellator, and geometry shader are traditionally used to feed
                                    primitive data into the rasterizer. With mesh shading, these steps can be
                                    replaced with one or two stages, and primitives can be generated in a compute
                                    shader fashion. This enables developers to increase flexibility and performance
                                    when defining 3D primitives, including procedural generation of 3D geometries,
                                    primitive culling, and other techniques.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_directX_view_instancing_vulkan_multiview">
                                <h3 class="VK_side_heading">
                                    DirectX* 12 View Instancing and Vulkan* Multiview
                                </h3>
                                <p>
                                    View Instancing is based on the observation that there are cases of redundant
                                    geometry processing where there is a shared use of the geometry between different
                                    views, based on the position of the camera. Examples of this include each side of a
                                    cube map, cascades of shadow maps, and/or stereo view.
                                </p>
                                <ul>
                                    <li>
                                        Normally the draw calls will be sent from the CPU to the GPU multiple times,
                                        which can become a bottleneck for scenes with many objects or draw calls. Xe-HPG
                                        introduces support for hardware that enables replicating geometry for multiple
                                        views in a single pass. Converting multiple passes, or instances where the
                                        geometry is processed the same way, to a single pass avoids redundant CPU and
                                        GPU work.
                                    </li>
                                    <li>
                                        Xe-HPG supports Tier 2 level view instancing on Direct3D* v12, and works in
                                        conjunction with VRS to enable further performance gains.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_directX_sampler_feedback">
                                <h3 class="VK_side_heading">
                                    DirectX 12 Sampler Feedback
                                </h3>
                                <p>
                                    Sampler feedback is a hardware-accelerated feature introduced in DirectX 12 Ultimate
                                    and supported by Xe-LP, Xe-HPG and later. Conceptually, it is the reverse of texture
                                    sampling: in contrast to the shader Sample() intrinsic, which reads a number of
                                    texels from a texture and returns an average value, the new WriteSamplerFeedback()
                                    shader intrinsic writes to a binary resource "marking" the texels that would have
                                    been read. This enables two important usages:
                                </p>
                                <ol>
                                    <li>
                                        Sampler Feedback Streaming: When objects are drawn, we can simultaneously
                                        collect data about what texture data was required to draw the scene. By
                                        dynamically streaming only those necessary portions of resources just-in-time,
                                        we can draw a scene that accesses more textures than could simultaneously fit in
                                        physical graphics memory. Sampler feedback includes a "min mip feedback" feature
                                        to facilitate this usage: a single-layer texture where each texel represents a
                                        region of the streaming texture with an integer (byte) representing the minimum
                                        mip that was sampled in that region. If the sampler feedback region size is set
                                        to match the tile dimensions of a partially resident resource, for example a
                                        DirectX 12 reserved resource, the result is a map that informs what tiles to
                                        stream. Min-mip feedback maps are very small—for example, for a 16Kx16K BC7
                                        reserved resource, the corresponding min mip feedback map with region size
                                        256x256 is only 64x64 bytes or 4 KB in size; much smaller than the 350 MB
                                        texture it represents.
                                    </li>
                                    <li>
                                        Texture Space Rendering: Intel pioneered texture space rendering in a SIGGRAPH
                                        2014 research paper [Clarberg et al. 2014]. We observed that the cost of pixel
                                        shading is tightly coupled to both the geometric complexity and the screen
                                        resolution, which has only increased over time. Instead of shading directly
                                        through traditional pixel shaders, the application uses sampler feedback to mark
                                        a mask which corresponds to the texels it requires. This mask can then be
                                        referenced in a subsequent compute shader pass, and the required texels can be
                                        shaded at a resolution and frequency determined by the developer in texture
                                        space, as opposed to a fixed screen-space resolution and frame frequency. Once
                                        shading to texels is completed in a separate lighter-weight pass, pixels in
                                        screen space are mapped into texture space, and the corresponding texels are
                                        sampled and filtered using standard-texture lookup operations. This feature
                                        allows pixel shading to be largely independent of the geometric complexity or
                                        screen resolution, providing a fine-grain control to trade quality for
                                        performance.
                                    </li>
                                </ol>
                                <p>
                                    For more information on sampler feedback, please visit the
                                    <a href="" class="Vk_text_underline_dots VK_a d-inline-block">
                                        GitHub* repository
                                    </a>
                                    that has sample code and links to the Intel Game Developer Conference (GDC) summer
                                    2021 presentation.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_DirectStorage">
                                <h3 class="VK_side_heading">
                                    DirectStorage
                                </h3>
                                <p>
                                    All Intel® platforms and graphics products support Microsoft* DirectStorage for
                                    Windows*. Performance of some usages will be dependent on features of the platform
                                    and devices. One desirable configuration for game loading and streaming experience
                                    includes the following:
                                </p>
                                <ul>
                                    <li>
                                        An Xe-HPG GPU that supports concurrent copy and render engines
                                    </li>
                                    <li>
                                        A 12th generation Intel® Core™ processor (such as the Intel® Core™ i9-12900K
                                        processor) that supports 24 lanes of PCIe* v4 and high-performance DDR5 memory
                                    </li>
                                    <li>
                                        A high-speed NVMe SSD.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_high_dynamic_range_displays">
                                <h3 class="VK_side_heading">
                                    High Dynamic Range Displays
                                </h3>
                                <p>
                                    Xe-HPG architecture features additional support and improvements for high dynamic
                                    range (HDR) images and displays. It’s integrated with half precision point (FP16)
                                    for faster rendering speeds of deep color bit depths (10, 12, and 16 bits per
                                    channel), supports up to the scRGB color gamut, and has a HDR10 protocol output and
                                    input capable of Dolby Vision*.
                                </p>
                                <p>
                                    Ultimately, Xe-HPG is fully compatible with the VESA Certified DisplayHDR* and Ultra
                                    High Definition (UHD) Premium* display certifications, and already supports Dolby
                                    Vision ahead of future consumer monitors release.
                                </p>
                                <p>
                                    HDR is supported in DirectX and Vulkan. For Vulkan, support can be found via the
                                    extension VK_EXT_hdr_metadata.
                                </p>
                                <p>
                                    For additional information on HDR, see:
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Using DirectX with High Dynamic Range Displays and Advanced Color.
                                    </a>
                                </p>
                            </section>
                            <section class="mt-4" id="VK_adaptive_sync_variable_refresh_rate">
                                <h3 class="VK_side_heading">
                                    Adaptive-Sync—Variable Refresh Rate
                                </h3>
                                <p>
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Adaptive-Sync
                                    </a>
                                    is the VESA standard for variable refresh rate displays. This display feature and
                                    controller enables a better experience for the user by reducing tearing and
                                    stuttering. Adaptive-Sync may also reduce overall system power consumption. Basic
                                    requirements for Adaptive-Sync are:
                                </p>
                                <ul>
                                    <li>
                                        Full-screen rendering by the game, or 3D application
                                    </li>
                                    <li>
                                        Simple application swap-chain modification to ensure asynchronous buffer flips
                                    </li>
                                    <li>
                                        A DisplayPort 1.4 VESA Adaptive-Sync capable display panel
                                    </li>
                                    <li>
                                        Windows® 10 RS5 and beyond
                                    </li>
                                </ul>
                                <p>
                                    The game, or 3D application, must ensure that its rendering swap-chain implements
                                    asynchronous buffer flips. On displays that support Adaptive-Sync, this results in
                                    smooth interactive rendering, with the display refresh dynamically synchronized with
                                    the asynchronous swap-chain flips. If application and platform conditions are met,
                                    the Xe-HPG driver enables Adaptive Sync by default. There is also an option to
                                    disable it using the Intel® Graphics Control Panel.
                                </p>
                                <p>
                                    On DirectX 12, use DXGI_SWAP_CHAIN_ALLOW_TEARING and DXGI_PRESENT_ALLOW_TEARING when
                                    creating the swap chain.
                                </p>
                                <p>
                                    On Vulkan, use VK_PRESENT_MODE_IMMEDIATE_KHR or VK_PRESENT_MODE_FIFO_KHR.
                                </p>
                                <p>
                                    For more information on enabling Adaptive-Sync, refer to the
                                    <a href="/VK_developers/VK_Enabling_Intel_Adaptive_11thgeneration_Intel_Processor_Graphics_DXGI_1.5Microsoft_DirectX12.html"
                                        class="Vk_text_underline_dots VK_a d-inline-block">
                                        Enabling Intel® Adaptive Sync Guide.
                                    </a>
                                </p>
                            </section>
                            <section class="mt-4" id="VK_other_API_feature_support">
                                <h3 class="VK_side_heading">
                                    Other API Feature Support
                                </h3>
                                <p>
                                    In addition to all these key features, Xe-HPG supports all the major APIs, including
                                    DirectX, OpenGL*, Vulkan, and OpenCL™ APIs. The table below shows the features
                                    discussed above, and others that are among the Direct3D 12 products mapped to
                                    Xe-HPG—as well as corresponding Vulkan support.
                                </p>
                                <p>
                                    Table 1. Xe-HPG Feature Support by API
                                </p>
                                <div class="overflow-auto">
                                    <table class="VK_side_nav_table">
                                        <thead class="VK_theme_thead">
                                            <tr>
                                                <th class="px-4 py-2">
                                                    API Feature
                                                </th>
                                                <th class="px-4 py-2">
                                                    DirectX 12 Support
                                                </th>
                                                <th class="px-4 py-2">
                                                    Vulkan Support
                                                </th>
                                            </tr>
                                        </thead>
                                        <tbody class="VK_theme_tbody">
                                            <tr>
                                                <td class="py-3">
                                                    Max Feature Level
                                                </td>
                                                <td class="py-3">
                                                    12_2
                                                </td>
                                                <td class="py-3">
                                                    N/A
                                                </td>
                                            </tr>
                                            <tr>
                                                <td class="py-3">
                                                    Shader Model
                                                </td>
                                                <td class="py-3">
                                                    6_6
                                                </td>
                                                <td class="py-3">
                                                    N/A
                                                </td>
                                            </tr>
                                            <tr>
                                                <td class="py-3">
                                                    Resource Binding
                                                </td>
                                                <td class="py-3">
                                                    Tier 3
                                                </td>
                                                <td class="py-3">
                                                    Limits Based on Driver Query
                                                </td>
                                            </tr>
                                            <tr>
                                                <td class="py-3">
                                                    Tiled Resources
                                                </td>
                                                <td class="py-3">
                                                    Tier 3
                                                </td>
                                                <td class="py-3">
                                                    Limits Based on Driver Query
                                                </td>
                                            </tr>
                                            <tr>
                                                <td class="py-3">
                                                    Typed UAV Loads
                                                </td>
                                                <td class="py-3">
                                                    Yes
                                                </td>
                                                <td class="py-3">
                                                    Yes—Core Spec
                                                </td>
                                            </tr>
                                            <tr>
                                                <td class="py-3">
                                                    Conservative Rasterization
                                                </td>
                                                <td class="py-3">
                                                    Yes
                                                </td>
                                                <td class="py-3">
                                                    Yes—VK_KHR_conservative_rasterization
                                                </td>
                                            </tr>
                                            <tr>
                                                <td class="py-3">
                                                    Rasterizer-Ordered Views
                                                </td>
                                                <td class="py-3">
                                                    Yes
                                                </td>
                                                <td class="py-3">
                                                    Yes—VK_EXT_fragment_shader_interlock
                                                </td>
                                            </tr>
                                            <tr>
                                                <td class="py-3">
                                                    Stencil Reference Output
                                                </td>
                                                <td class="py-3">
                                                    Yes
                                                </td>
                                                <td class="py-3">
                                                    Yes—VK_EXT_shader_stencil_export
                                                </td>
                                            </tr>
                                            <tr>
                                                <td class="py-3">
                                                    UAV Slots
                                                </td>
                                                <td class="py-3">
                                                    Full Heap
                                                </td>
                                                <td class="py-3">
                                                    Limits Based on Driver Query
                                                </td>
                                            </tr>
                                            <tr>
                                                <td class="py-3">
                                                    Resource Heap
                                                </td>
                                                <td class="py-3">
                                                    Tier 1
                                                </td>
                                                <td class="py-3">
                                                    N/A
                                                </td>
                                            </tr>
                                            <tr>
                                                <td class="py-3">
                                                    Variable Rate Shading
                                                </td>
                                                <td class="py-3">
                                                    Tier 2
                                                </td>
                                                <td class="py-3">
                                                    VK_KHR_fragment_shading_rate
                                                </td>
                                            </tr>
                                            <tr>
                                                <td class="py-3">
                                                    View Instancing
                                                </td>
                                                <td class="py-3">
                                                    Tier 2
                                                </td>
                                                <td class="py-3">
                                                    Yes—VK_KHR_multiview
                                                </td>
                                            </tr>
                                            <tr>
                                                <td class="py-3">
                                                    Asynchronous Compute
                                                </td>
                                                <td class="py-3">
                                                    Yes
                                                </td>
                                                <td class="py-3">
                                                    Yes—Core Spec
                                                </td>
                                            </tr>
                                            <tr>
                                                <td class="py-3">
                                                    Depth Bounds Test
                                                </td>
                                                <td class="py-3">
                                                    Yes
                                                </td>
                                                <td class="py-3">
                                                    Yes—Core Spec
                                                </td>
                                            </tr>
                                            <tr>
                                                <td class="py-3">
                                                    Sampler Feedback
                                                </td>
                                                <td class="py-3">
                                                    Tier 0.9
                                                </td>
                                                <td class="py-3">
                                                    N/A
                                                </td>
                                            </tr>
                                            <tr>
                                                <td class="py-3">
                                                    Ray Tracing
                                                </td>
                                                <td class="py-3">
                                                    DXR 1.0/1.1
                                                </td>
                                                <td class="py-3">
                                                    See Hardware Ray-Tracing Support
                                                </td>
                                            </tr>
                                            <tr>
                                                <td class="py-3">
                                                    Mesh Shading
                                                </td>
                                                <td class="py-3">
                                                    Tier 1
                                                </td>
                                                <td class="py-3">
                                                    Work in Progress
                                                </td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </section>
                            <section class="mt-4" id="VK_tools_for_performance_analysis">
                                <h3 class="VK_side_heading fw-light">
                                    Tools for Performance Analysis
                                </h3>
                                <p>
                                    Intel recommends using
                                    <a href="/dhruvin_developer-tools/Development-Tools/ds_Graphics-Performance-Analyzers.html"
                                        class="Vk_text_underline_dots VK_a d-inline-block">
                                        Intel® Graphics Performance Analyzers (Intel® GPA)
                                    </a>
                                    and
                                    <a href="" class="Vk_text_underline_dots VK_a d-inline-block">
                                        Intel® VTune™ Profiler
                                    </a>
                                    as the primary optimization tools for performance analysis on Xe-HPG. The Intel GPA
                                    Cookbook is found
                                    <a href="/VK_developers/VK_resourse.html"
                                        class="Vk_text_underline_dots VK_a d-inline-block">
                                        here
                                    </a>
                                    Intel GPA is updated frequently with new features to help you debug and profile your
                                    application.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_performance_recommendations_for_Intel_graphics_processors">
                                <h3 class="VK_side_heading fw-light">
                                    Performance Recommendations for Intel Xe-HPG Graphics Processors
                                </h3>
                                <p>
                                    Modern graphics APIs, such as DirectX 12 and Vulkan, give developers more control
                                    over lower-level choices that were once handled in driver implementations. Each API
                                    is different, however, and these are general recommendations for application
                                    developers that are not API-specific.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_GPU_detection_for_features">
                                <h3 class="VK_side_heading">
                                    GPU Detection for Features
                                </h3>
                                <p>
                                    Xe-HPG supports various hardware features that are supported natively in DirectX 12
                                    or Vulkan. When querying, enabling, or disabling hardware features, keep the
                                    following in mind:
                                </p>
                                <ul>
                                    <li>
                                        Avoid using vendor IDs to disable features, use slower execution paths, or
                                        default to lower performance settings.
                                    </li>
                                    <li>
                                        Query the hardware for support using defined APIs.
                                    </li>
                                    <li>
                                        Favor vendor-agnostic features, when available, over hardware vendor-specific
                                        extensions.
                                    </li>
                                    <li>
                                        Check for support on optional features in an API.
                                    </li>
                                </ul>
                                <p>
                                    To help with detection of Intel® GPUs, Intel has a
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        GPU Detect sample
                                    </a>
                                    to assist with this process.
                                </p>
                                <p>
                                    Intel’s driver versioning has also been updated. For more information refer to
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Understanding the Intel® Graphics Driver Version Number.
                                    </a>
                                </p>
                            </section>
                            <section class="mt-4" id="VK_additional_notes">
                                <h3 class="VK_side_heading">
                                    Additional Notes
                                </h3>
                                <ul>
                                    <li>
                                        Xe-HPG does not support double precision floats in hardware. Use
                                        CheckFeatureSupport and query the DoublePrecisionFloatShaderOps member of the
                                        D3D12_FEATURE_DATA_D3D12_OPTIONS struct to check for support before using in
                                        shaders.
                                    </li>
                                    <li>
                                        For compute shaders, Single Instruction Multiple Data (SIMD) lane count is not
                                        fixed but is variable depending on factors later highlighted in this guide in
                                        the Shader Optimizations section. Shaders should not assume wave size is fixed.
                                        Barycentrics are not supported.
                                    </li>
                                    <li>
                                        Divergent barriers in shaders can cause hangs.
                                    </li>
                                    <li>
                                        Uninitialized descriptor heaps are undefined behavior and may cause issues.
                                    </li>
                                </ul>
                                <p>
                                    For more information about GPU detect, and a description of driver version schemes,
                                    consult this
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        article.
                                    </a>
                                </p>
                            </section>
                            <section class="mt-4" id="VK_configuring_graphics_pipeline_state">
                                <h3 class="VK_side_heading">
                                    Configuring Graphics Pipeline State
                                </h3>
                                <p>
                                    When configuring pipeline states, consider the following:
                                </p>
                                <ul>
                                    <li>
                                        Take advantage of all the available CPU threads on the system when creating
                                        Pipeline State Objects (PSOs). In previous APIs, the driver would create these
                                        threads for you, but now you must create the threads yourself.
                                    </li>
                                    <li>
                                        Define optimized shaders for PSOs instead of using combinations of generic
                                        shaders mixed with specialized shaders.
                                    </li>
                                    <li>
                                        Avoid defining depth-plus-stencil format, when stencil will not be used. Use
                                        depth-only formats, such as D32.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_resource_binding">
                                <h3 class="VK_side_heading">
                                    Resource Binding
                                </h3>
                                <p>
                                    The latest graphics APIs give you more control over resource binding, such as with
                                    DirectX root signatures, and Vulkan pipeline layout. Using these resources requires
                                    particular attention to maximize performance. When designing an application strategy
                                    for resource binding, employ the following guidance:
                                </p>
                                <ul>
                                    <li>
                                        Minimize the number of root signature slots, or descriptor sets, to only what
                                        will be used by a shader.
                                    </li>
                                    <li>
                                        Find a balance between root signature, or descriptor set, reuse across shaders.
                                    </li>
                                    <li>
                                        Consider packing all constant buffer views into one descriptor table for
                                        multiple constant buffers that do not change between draws.
                                    </li>
                                    <li>
                                        For multiple unordered access views (UAV) and shader resource views (SRV) that
                                        do not span a consecutive range of registers, and do not change between draws,
                                        it is best to pack them into a descriptor table.
                                    </li>
                                    <li>
                                        Minimize descriptor heap changes. Changing descriptor heaps severely stalls the
                                        graphics pipeline. Ideally, all resources will have views appropriated out of
                                        one descriptor heap.
                                    </li>
                                    <li>
                                        Avoid generic root signature definitions where unnecessary descriptors are
                                        defined, and not leveraged. Instead, optimize root-signature definitions to the
                                        minimal set of descriptor tables needed.
                                    </li>
                                    <li>
                                        Favor root constants over root descriptors, and favor root descriptors over
                                        descriptor tables when working with constants.
                                        <ul>
                                            <li>
                                                Make use of root/
                                                <a href="" class="Vk_text_underline_dots VK_a">
                                                    push constants
                                                </a>
                                                to enable fast access to constant buffer data (they are preloaded into
                                                registers).
                                            </li>
                                            <li>
                                                Root/push constants are great to use on frequently changing constant
                                                buffer data.
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        Use root/push constants for cases where the constants are changing at a high
                                        frequency.
                                        <ul>
                                            <li>
                                                If certain root signature slots are less frequently used (i.e., not
                                                referenced by a PSO), put those at the end of the root signature to
                                                reduce graphics resource file (GRF) usage.
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        Use hints that allow the driver to perform constant-based optimizations, such as
                                        <br>
                                        D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC.
                                    </li>
                                    <li>
                                        For placed resources, initialize using clear, copy, or discard, before rendering
                                        to the resource. This helps enable proper compression by putting the placed
                                        resource into a valid state.
                                    </li>
                                    <li>
                                        When creating resource heaps, resources that need to be accessed by the GPU
                                        should be placed in heaps that are declared as resident in GPU memory—preferably
                                        exclusively. Default heaps are preferred over upload heaps for constant buffers.
                                        This has a significant impact on discrete GPU performance.
                                    </li>
                                    <li>
                                        Use queries to identify scenarios when GPU local memory gets oversubscribed, and
                                        adjust resource location to accommodate this. On one device the memory footprint
                                        may be fine but may be oversubscribed on a different device.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_render_targets_and_textures">
                                <h3 class="VK_side_heading">
                                    Render Targets and Textures
                                </h3>
                                <p>
                                    Most developers optimize texture data for GPU or CPU access, based on a given
                                    texture’s storage mode, and its use in the app. However, you can explicitly optimize
                                    texture data for either processor or opt out of optimization altogether. When
                                    texture data is optimized, performance increases for one processor but decreases for
                                    the other. Before optimizing texture data, carefully consider the storage modes and
                                    usage options for your textures.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_general_guidance">
                                <h3 class="VK_n22 fw-normal">
                                    General Guidance
                                </h3>
                                <p>
                                    The following application guidelines ensure the efficient use of bandwidth with
                                    render targets:
                                </p>
                                <ul>
                                    <li>
                                        Avoid defining unnecessary channels, or higher precision data formats, when not
                                        needed to conserve memory bandwidth and optimize cache fetches.
                                    </li>
                                    <li>
                                        Create multiple resources from the same memory-object.
                                    </li>
                                    <li>
                                        Create resources (when possible) in the state that they will first be used. For
                                        example, starting in COMMON state then transitioning to DEPTH_WRITE will cause a
                                        Hi-Z resolve. Starting in DEPTH_WRITE, for this example, is optimal.
                                    </li>
                                </ul>
                                <p>
                                    Vulkan specific advice for optimal device access:
                                </p>
                                <ul>
                                    <li>
                                        Always use VK_IMAGE_LAYOUT_{}_OPTIMAL for GPU access.
                                    </li>
                                    <li>
                                        Only use VK_IMAGE_LAYOUT_GENERAL when really needed.
                                    </li>
                                    <li>
                                        Only use VK_IMAGE_CREATE_MULTIPLE_FORMAT_BIT when really needed.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_UAVs_and_SSBOs">
                                <h3 class="VK_n22">
                                    UAVs and SSBOs
                                </h3>
                                <p>
                                    When dealing with resources that have both read- and write-access in a shader, such
                                    as UAVs and shader storage buffer objects (SSBOs), consider the following:
                                </p>
                                <ul>
                                    <li>
                                        Access to read-only data is much more efficient than read/write data. Use
                                        read/write kinds of resources with caution, and when there are no better
                                        options.
                                    </li>
                                    <li>
                                        Do not set a resource to use a SSBO in a Vulkan bind flag if the resource will
                                        never be bound as a UAV. This programming behavior may disable resource
                                        compression.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Anti_Aliasing">
                                <h3 class="VK_n22">
                                    Anti-Aliasing
                                </h3>
                                <p>
                                    To get the best performance when performing multi-sample anti-aliasing, the
                                    following tips are recommended:
                                </p>
                                <ul>
                                    <li>
                                        Minimize the use of stencil, or blend, when multi-sample anti-aliasing (MSAA) is
                                        enabled.
                                    </li>
                                    <li>
                                        Avoid querying resource information from within a loop or branch where the
                                        result is immediately consumed or duplicated across loop iterations.
                                    </li>
                                    <li>
                                        Minimize per-sample operations. When shading per sample, maximize the number of
                                        cases where any kill pixel operation is used to get the best surface
                                        compression.
                                    </li>
                                </ul>
                                <p>
                                    We do recommend using optimized post-processing anti-aliasing, such as Temporal
                                    Anti-Aliasing, and/or
                                    <a href="/dhruvin_developer-tools/ds_Developer-Zone.html"
                                        class="Vk_text_underline_dots VK_a">
                                        Conservative Morphological Anti-Aliasing 2.0.
                                    </a>
                                    Alternatively, advanced upscaling technologies such as Intel® Xe Super Sampling will
                                    produce high resolution, anti-aliased images.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_resource_barriers">
                                <h3 class="VK_n22">
                                    Resource Barriers
                                </h3>
                                <p>
                                    Each resource barrier generally results in a cache flush, or GPU stall operation,
                                    that affects performance. Given that, the following guidelines are recommended:
                                </p>
                                <ul>
                                    <li>
                                        Batch pipeline barriers. Use render passes to help properly batch barriers, and
                                        allow the driver to defer and hoist barriers to render pass edges.
                                    </li>
                                    <li>
                                        If you need to use barrier- only command lists, the preference is to submit
                                        barrier-only command lists with other work, preferably at the end of the execute
                                        command list as trailing command lists. This will avoid paying extra
                                        synchronization costs. Alternately, submit at the very start as the first
                                        command list in an execute command lists call.
                                    </li>
                                    <li>
                                        Use implicit render pass barriers when possible.
                                    </li>
                                    <li>
                                        Limit the number of resource transitions by batching them and avoid interleaving
                                        with dispatches/render passes.
                                    </li>
                                    <li>
                                        Batch barriers with render target changes, and avoid states such as
                                        D3D12_RESOURCE_STATE_COMMON—unless necessary for presenting, context sharing, or
                                        CPU access.
                                    </li>
                                    <li>
                                        Supply resources when possible for barriers; they allow more optimal GPU cache
                                        flushing, especially for aliasing buffers.
                                    </li>
                                    <li>
                                        Employ split barriers when possible to allow for maximum predication of
                                        synchronizing events. Signaling should happen as early as possible and wait as
                                        late as possible.
                                    </li>
                                    <li>
                                        When transitioning resource states, do not over-set them when not in use; it can
                                        lead to excessive cache flushes.
                                    </li>
                                    <li>
                                        For Vulkan, only use transitions from UNDEFINED state when really needed.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_command_submissions">
                                <h3 class="VK_n22">
                                    Command Submissions
                                </h3>
                                <p>
                                    When working with command queues and buffers, the following are recommended:
                                </p>
                                <ul>
                                    <li>
                                        Batch command list submission at ExecuteCommandLists in DirectX 12 and Vulkan
                                        when possible, but not to the point where the GPU is starved. This ensures
                                        efficient use of the CPU and GPU.
                                    </li>
                                    <li>
                                        When filling command buffers or command queues, use multiple CPU cores when
                                        possible. This reduces single-core CPU bottlenecking of your application.
                                    </li>
                                    <li>
                                        When using ExecuteIndirect
                                        <ul>
                                            <li>
                                                Use high max counts in each ExecuteIndirect call
                                            </li>
                                            <li>
                                                Avoid ExecuteIndirect calls on buffers of size zero or one. For size
                                                zero use predication.
                                            </li>
                                            <li>
                                                Generate arguments for many ExecuteIndirect calls together, then issue
                                                the ExecuteIndirect calls in batchs. Generating a single argument
                                                followed by a single ExecuteIndirect in a loop is inefficient.
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                                <p class="m-0">
                                    DirectX 12 recommendation:
                                </p>
                                <ul>
                                    <li>
                                        Avoid the overuse of bundles, as they may incur additional CPU and GPU overhead.
                                    </li>
                                </ul>
                                <p class="m-0">
                                    Vulkan recommendations:
                                </p>
                                <ul>
                                    <li>
                                        Use primary command buffers where possible, as these provide better performance
                                        due to internal batch buffer usage.
                                    </li>
                                    <li>
                                        For primary command buffers, use USAGE_ONE_TIME_SUBMIT_BIT.
                                    </li>
                                    <li>
                                        For primary command buffers, avoid USAGE_SIMULTANEOUS_USE_BIT.
                                    </li>
                                    <li>
                                        Minimize the use of secondary command buffers as they are less efficient than
                                        primary command buffers and not as efficient with depth-clears.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Optimizing_Clear_Copy_and_Update_Operations">
                                <h3 class="VK_n22">
                                    Optimizing Clear, Copy, and Update Operations
                                </h3>
                                <p>
                                    For the best performance on clear, copy, and update operations, follow these
                                    guidelines:
                                </p>
                                <ul>
                                    <li>
                                        Use the API provided functions for clear, copy, and update operations, and
                                        refrain from implementing your own versions. Drivers have been optimized and
                                        tuned to ensure that these operations work with the best possible performance.
                                    </li>
                                    <li>
                                        There is no “clear color” value in Vulkan. Clear the entire image (all layers)
                                        at the same time, rather than layer-by-layer. Enable hardware “fast clear”
                                        values as defined per API:
                                        <ul>
                                            <li>
                                                In DirectX 12, clear values are defined at resource creation as an
                                                argument with ID3D12Device::CreateCommittedResource. Use this defined
                                                clear-value for clear operations on that resource.
                                            </li>
                                            <li>
                                                For Vulkan, use VK_ATTACHMENT_LOAD_OP_CLEAR and avoid using
                                                VkCmdClearColorImage() to clear all layers at the same time.
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        Copy depth and stencil surfaces only as needed, instead of copying both
                                        unconditionally; they are stored separately on Xe-HPG.
                                    </li>
                                    <li>
                                        Batch the clear and copy operations and execute the barriers at the beginning
                                        and end of batches.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Geometry_Transformation">
                                <h3 class="VK_n22">
                                    Geometry Transformation
                                </h3>
                                <p>
                                    To ensure that vertex and geometry shader functions operate optimally, consider the
                                    following guidelines:
                                </p>
                                <ul>
                                    <li>
                                        Ensure all bound attributes are used. When a draw is bottlenecked on geometry
                                        work, reducing the number of attributes per vertex can improve performance.
                                    </li>
                                    <li>
                                        Implement a level-of-detail system that allows flexibility in model accuracy by
                                        adjusting the number of vertices per model, per level-of-detail.
                                    </li>
                                    <li>
                                        Implement efficient CPU occlusion culling to avoid submitting hidden geometry.
                                        This approach can save both CPU (draw submission) and GPU (render) time. We
                                        suggest using Intel’s highly optimized
                                        <a href="/VK_developers/VK_Masked_Software_Occlusion_Culling.html"
                                            class="Vk_text_underline_dots VK_a">
                                            Masked Software Occlusion Culling
                                        </a>
                                        for this. It can eventually be used in combination with finer-grain GPU culling.
                                    </li>
                                    <li>
                                        Define input geometries as a structure of arrays for vertex buffers. Try to
                                        group position information vertex data in its own input slot to assist the tile
                                        binning engine for tile-based rendering.
                                    </li>
                                    <li>
                                        The Xe-HPG vertex cache does not cache instanced attributes. For instanced
                                        calls, consider loading attributes explicitly in your vertex shader.
                                    </li>
                                    <li>
                                        For full-screen post-processing passes, use a single triangle that covers the
                                        entire screen space, instead of two triangles to form a quad. The shared
                                        triangle edge in the two triangles use-case results in sub-optimal utilization
                                        of compute resources.
                                    </li>
                                    <li>
                                        Optimize vertex attribute inputs to only include attributes that will be used in
                                        the vertex shader and downstream stages. This enables better use of bandwidth
                                        and space with the L2 cache.
                                    </li>
                                    <li>
                                        Optimize transformation shaders (that is, vertex to geometry shader) to output
                                        only attributes that will be used by later stages in the pipeline. For example,
                                        avoid defining unnecessary outputs from a vertex shader that will not be
                                        consumed by a pixel shader. This enables better use of bandwidth and space with
                                        the L2 cache. This applies to vertex input as well by saving on memory
                                        bandwidth.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_shader_Optimizations">
                                <h3 class="VK_n22">
                                    Shader Optimizations
                                </h3>
                                <p>
                                    The more computations and processing your shader code performs, the more important
                                    it is that you take steps to optimize the process for peak performance. For example,
                                    the frequency of performing complex computations has a big impact on the performance
                                    of your game.
                                </p>
                            </section>
                            <section class="mt-4" id="VK_General_Shader_Guidance">
                                <h3 class="VK_n22">
                                    General Shader Guidance
                                </h3>
                                <p>
                                    When writing shaders, look for these opportunities to optimize:
                                </p>
                                <ul>
                                    <li>
                                        Xe-HPG supports double-rate FP16 math. Use lower precision when possible. Also,
                                        note that Xe-HPG removed FP64 support to improve power and performance. Make
                                        sure that you query hardware support for double rate and ensure proper fallback.
                                    </li>
                                    <li>
                                        Structure the shader to avoid unnecessary dependencies, especially high-latency
                                        operations, such as sampling or memory fetches.
                                    </li>
                                    <li>
                                        For performance reasons try to avoid shader control flow based on results from
                                        sampling operations.
                                    </li>
                                    <li>
                                        Aim for uniform execution of shaders by avoiding flow control based on
                                        non-uniform variables.
                                    </li>
                                    <li>
                                        Implement early returns in shaders where the output of an algorithm can be
                                        predetermined or computed at a lower cost than that of the full algorithm.
                                    </li>
                                    <li>
                                        Use shader semantics to flatten, branch, loop, and unroll wisely. It is often
                                        better to specify the desired unrolling behavior, rather than let the shader
                                        compiler make those decisions.
                                    </li>
                                    <li>
                                        Branching is preferable if there are enough instruction cycles saved that
                                        outweigh the cost of branching.
                                    </li>
                                    <li>
                                        Extended math and sampling operations have a higher weight, and may be worth
                                        branching (see Table 2 for issue rates).
                                    </li>
                                </ul>
                                <p>
                                    Table 2. Xe-HPG Vector Engine (XVE) instruction issue rates
                                </p>
                                <div class="overflow-auto">
                                    <table class="VK_side_nav_table">
                                        <thead class="VK_theme_thead">
                                            <tr>
                                                <th class="py-2 px-2">
                                                    Instruction
                                                </th>
                                                <th class="py-2 px-2">
                                                    Single Precision (ops/VE/clk)
                                                </th>
                                                <th class="py-2 px-2">
                                                    Theoretical Cycle Count
                                                </th>
                                            </tr>
                                        </thead>
                                        <tbody class="VK_theme_tbody">
                                            <tr>
                                                <td class="px-2 py-3">
                                                    FMAD
                                                </td>
                                                <td class="px-2 py-3">
                                                    8
                                                </td>
                                                <td class="px-2 py-3">
                                                    1
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>
                                                    FMUL
                                                </td>
                                                <td>
                                                    8
                                                </td>
                                                <td>
                                                    1
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>
                                                    FADD
                                                </td>
                                                <td>
                                                    8
                                                </td>
                                                <td>
                                                    1
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>
                                                    MIN/MAX
                                                </td>
                                                <td>
                                                    8
                                                </td>
                                                <td>
                                                    1
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>
                                                    CMP
                                                </td>
                                                <td>
                                                    8
                                                </td>
                                                <td>
                                                    1
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>
                                                    INV
                                                </td>
                                                <td>
                                                    2
                                                </td>
                                                <td>
                                                    4
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>
                                                    SQRT
                                                </td>
                                                <td>
                                                    2
                                                </td>
                                                <td>
                                                    4
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>
                                                    RSQRT
                                                </td>
                                                <td>
                                                    2
                                                </td>
                                                <td>
                                                    4
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>
                                                    LOG
                                                </td>
                                                <td>
                                                    2
                                                </td>
                                                <td>
                                                    4
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>
                                                    EXP
                                                </td>
                                                <td>
                                                    2
                                                </td>
                                                <td>
                                                    4
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>
                                                    POW
                                                </td>
                                                <td>
                                                    1
                                                </td>
                                                <td>
                                                    8
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>
                                                    IDIV
                                                </td>
                                                <td>
                                                    1-6
                                                </td>
                                                <td>
                                                    1.33-8
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>
                                                    TRIG
                                                </td>
                                                <td>
                                                    2
                                                </td>
                                                <td>
                                                    4
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>
                                                    FDIV
                                                </td>
                                                <td>
                                                    1
                                                </td>
                                                <td>
                                                    8
                                                </td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                                <ul>
                                    <li>
                                        Small branches of code may perform better when flattened.
                                    </li>
                                    <li>
                                        Unroll conservatively. In most cases, unrolling short loops helps performance.
                                        However, unrolling loops does increase the shader instruction count. Unrolling
                                        long loops with high iteration counts can impact shader residency in instruction
                                        caches and therefore negatively impact performance.
                                    </li>
                                    <li>
                                        Avoid extra sampler operations when it is possible that the sampler operation
                                        will later be multiplied by zero. For example, when interpolating between two
                                        samples, if there is a high probability of the interpolation being zero or one,
                                        a branch can be added to speed up the common case and only perform the load only
                                        when needed.
                                    </li>
                                    <li>
                                        Avoid querying resource information at runtime—for example, High-Level Shading
                                        Language (HLSL) GetDimensions calls to make decisions on control flow—or
                                        unnecessarily incorporating resource information into algorithms.
                                    </li>
                                    <li>
                                        When passing attributes to the pixel shader, mark attributes that do not change
                                        per vertex within a primitive as constant.
                                    </li>
                                    <li>
                                        For shaders where depth-test is disabled, use discard (or other kill operations)
                                        where output will not contribute to the final color in the render target.
                                        Blending can be skipped where the output of the algorithm has an alpha channel
                                        value of zero or where adding inputs into shaders that are zeros that negate
                                        output.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Texture_Sampling">
                                <h3 class="VK_n22">
                                    Texture Sampling
                                </h3>
                                <p>
                                    To get the best performance out of textures and texture operations, please consider
                                    the following items:
                                </p>
                                <ul>
                                    <li>
                                        When sampling from a render target, note that sampling across mip levels of the
                                        surface, with instructions such as sample_l/sample_b, is costly.
                                    </li>
                                    <li>
                                        Use API defined and architecture-supported compression formats (that is,
                                        BC1-BC7) on larger textures to improve memory bandwidth utilization, and improve
                                        memory locality, when performing sampling operations.
                                    </li>
                                    <li>
                                        Avoid dependent texture samples between sample instructions. For example, avoid
                                        making the UV coordinates of the next sample operation dependent upon the
                                        results of the previous sample operation. In this instance, the shader compiler
                                        may not be able to optimize or reorder the instructions, and it may result in a
                                        sampler bottleneck.
                                    </li>
                                    <li>
                                        Avoid redundant and duplicate sampler states within shader code, and use
                                        static/immutable samplers, if possible.
                                    </li>
                                    <li>
                                        Define appropriate resource types for sampling operation and filtering mode. Do
                                        not use volumetric surface as a 2D array.
                                    </li>
                                    <li>
                                        For best performance when fetching from an array surface, ensure that the index
                                        is uniform across shader instances co-executing in SIMD lanes to ensure the best
                                        performance.
                                    </li>
                                    <li>
                                        Avoid defining constant data in textures that could be procedurally computed in
                                        the shader, such as gradients.
                                    </li>
                                    <li>
                                        Avoid anisotropic filtering on sRGB textures.
                                    </li>
                                    <li>
                                        Sample_d provides gradient-per-pixels and throughput drops to one-fourth. Prefer
                                        sample_l unless anisotropic filtering is required.
                                    </li>
                                    <li>
                                        When using VRS, anisotropic filtering may not be needed, as pixels in that draw
                                        will be coarser. Non-anisotropic filtering improves sampler throughput.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Constants">
                                <h3 class="VK_n22">
                                    Constants
                                </h3>
                                <p>
                                    When defining shader constants, the following guidelines can help to achieve better
                                    performance:
                                </p>
                                <ul>
                                    <li>
                                        Structure constant buffers to improve cache locality so that memory accesses all
                                        occur on the same cache line, which improves memory performance.
                                    </li>
                                    <li>
                                        Favor constant access that uses direct access, since the offset is known at
                                        compile time, rather than indirect access, in which the offset must be computed
                                        at runtime. This benefits high-latency operations like flow-control and
                                        sampling.
                                    </li>
                                    <li>
                                        Group the more frequently used constants for better cache utilization, and move
                                        them to the beginning of the buffer.
                                    </li>
                                    <li>
                                        Organize constants by frequency of update, and only upload when the values
                                        change.
                                    </li>
                                    <li>
                                        When loading data from buffers or structured buffers, organize the data access
                                        in such a way that all, or the majority, of the cache line is used. For example,
                                        if a structured buffer has ten attributes, and only one of those attributes is
                                        used for reading and/or writing, it would be better to split that one attribute
                                        into its own structured buffer.
                                    </li>
                                    <li>
                                        Consider using ByteAddressBuffers when performing consecutive data loads,
                                        instead of loading data from a Typed Buffer. Those can be optimized by our
                                        shader compiler.
                                    </li>
                                    <li>
                                        Developers will see the best performance in shaders that avoid sparsely
                                        referencing the constant data in constant buffers. Best performance will also be
                                        achieved if only up to two constant buffers are referenced in non-compute
                                        shaders.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Temporary_Register_Variable_Usage">
                                <h3 class="VK_n22">
                                    Temporary Register Variable Usage
                                </h3>
                                <p>
                                    Each thread on a vector engine has its own set of registers to store values. The
                                    more work that can be done using these register operations, the more can be done to
                                    help reduce memory-penalties. However, if there are more temporary variables than
                                    registers, some of those variables will have to be stored in memory, where reading
                                    and writing have a latency cost. Avoiding this spillover can help to improve
                                    performance.
                                </p>
                                <p>
                                    On Xe-HPG, reducing register pressure allows not only an increase in SIMD width but
                                    also significantly better code scheduling.
                                </p>
                                <p class="m-0">
                                    When writing shaders, there is only limited control of how registers get allocated.
                                    The following guidelines should be considered to help reduce spillover and improve
                                    performance:
                                </p>
                                <ul>
                                    <li>
                                        Try to optimize the number of temporaries to 16, or fewer, per shader. This
                                        limits the number of register transfers to and from main memory, which has
                                        higher latency costs. Check the instruction set assembly code output and look
                                        for spill-count. Spills are a good opportunity for optimization, as they reduce
                                        the number of operations that depend on high-latency memory operations. This can
                                        be done in Intel GPA by selecting a shader and choosing to look at the
                                        machine-code generated by the compiler.
                                    </li>
                                    <li>
                                        If possible, move the declaration and assignment of a variable closer to where
                                        it will be referenced.
                                    </li>
                                    <li>
                                        Weigh the options between full and partial precision on variables, as this can
                                        store more values in the same space. Use caution when mixing partial precision
                                        with full precision in the same instruction, as it may cause redundant
                                        type-conversions.
                                    </li>
                                    <li>
                                        Move redundant code that is common between branches out of the branch. This can
                                        reduce redundant variable duplication.
                                    </li>
                                    <li>
                                        Avoid non-uniform access to constant buffer/buffer data. Non-uniform access
                                        requires more temporary registers to store data per SIMD lane.
                                    </li>
                                    <li>
                                        Control-flow decisions based on constant buffer data forces the compiler to
                                        generate sub-optimal machine code. Instead, use specialization constants, or
                                        generate multiple specialized shader permutations when possible.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Compute_Shader_Considerations">
                                <h3 class="VK_n22">
                                    Compute Shader Considerations
                                </h3>
                                <p class="m-0">
                                    When developing compute shaders, the following guidelines can help to achieve
                                    optimal performance when selecting thread-group sizes:
                                </p>
                                <ul>
                                    <li>
                                        Pick thread-group sizes and dimensions that fit the nature of your workload’s
                                        memory access patterns. For instance, if your application accesses memory in a
                                        linear fashion, specify a linear dimension thread-group size, such as 64 x 1 x
                                        1.
                                    </li>
                                    <li>
                                        For two-dimensional thread groups, smaller thread-group sizes typically lead to
                                        better performance and achieve better vector engine thread occupancy.
                                    </li>
                                    <li>
                                        Generally, a thread-group size of 8 x 8 performs well on Xe-HPG. In some cases,
                                        this may not be optimal due to memory access patterns, and/or cache locality. In
                                        this case, 16 x 16 or higher dimensions should be experimented with and chosen
                                        based on their performance in testing.
                                    </li>
                                    <li>
                                        Thread-group sizes higher than or equal to 256 threads can cause thread
                                        occupancy issues.
                                    </li>
                                    <li>
                                        Shared local memory variable-based atomics have fewer memory hierarchy
                                        implications, making them more efficient than atomics on UAVs.
                                    </li>
                                    <li>
                                        For efficient use of Xe-cores, ensure thread-group sizes are a multiple of 32
                                        threads total. This ensures fused Vector Engine pairs run efficiently.
                                    </li>
                                </ul>
                                <p class="m-0">
                                    When developing compute shaders that use Shared Local Memory (SLM), consider the
                                    following:
                                </p>
                                <ul>
                                    <li>
                                        Load an array of float4 data in one bank of float4 types, rather than four banks
                                        of float arrays.
                                    </li>
                                    <li>
                                        Try to keep variables in registers, rather than SLM, to save on memory access
                                        penalties.
                                    </li>
                                    <li>
                                        Load and store data in such a manner that data elements that are consecutively
                                        accessed are located back-to-back. This allows read and write access to be
                                        coalesced, and to use memory bandwidth efficiently.
                                    </li>
                                    <li>
                                        Use HLSL interlocked functions to perform min, max, or, and other,
                                        reductions—instead of moving data to and from SLM to perform the same operation
                                        with a user-defined operation. The compiler can map HLSL functions to a
                                        hardware-implemented version.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Wave_Intrinsics">
                                <h3 class="VK_n22">
                                    Wave Intrinsics
                                </h3>
                                <p class="m-0">
                                    Xe-HPG supports the use of wave intrinsics for both 3D and compute workloads. These
                                    can be used to write more efficient, register-based reductions, and to reduce
                                    reliance on global or local memory for communication across lanes. This allows
                                    threads within the thread-group to share information without the use of barriers,
                                    and to enable other cross-lane operations for threads in the same wave. While
                                    working with wave intrinsics, consider the following:
                                </p>
                                <ul>
                                    <li>
                                        Do not write shaders that assume a specific machine-width. On Gen architecture,
                                        wave width can vary across shaders from SIMD8, SIMD16, and SIMD32, and is chosen
                                        by heuristics in the shader compiler. Because of this, use instructions such as
                                        WaveGetLaneCount() in algorithms that depend on wave size.
                                    </li>
                                    <li>
                                        Wave operations can be used to reduce memory bandwidth by enabling access to
                                        data already stored in registers by other threads, instead of storing and
                                        re-loading results from memory. It is a great fit for optimizing operations such
                                        as texture mipmap generation.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Frame_Presentation">
                                <h3 class="VK_n22">
                                    Frame Presentation
                                </h3>
                                <p class="m-0">
                                    For the best performance and compatibility across different Windows versions, it is
                                    recommended to use full-screen presentation modes, if possible. Other modes require
                                    an extra context switch and full-screen copy. On Windows 10 and Windows 11, it is
                                    possible to use full-screen, borderless windowed modes with no penalty, and no
                                    performance loss to the Desktop Window Manager. If in doubt, use tools such as
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        PresentMon
                                    </a>
                                    to know which presentation mode is active, and GPUView (part of the Windows 10 SDK)
                                    for possible intervention by the Desktop Window Manager. Ensure that PresentMon
                                    reports “Hardware Composed: Independent Flip” (see Table 3), and that no activity is
                                    reported by DWM.exe in your ETW trace.
                                </p>
                                <p>
                                    Table 3: Optimal Present Mode, as reported by PresentMon
                                </p>
                                <div class="overflow-auto">
                                    <table class="VK_side_nav_table">
                                        <thead class="VK_theme_thead">
                                            <tr>
                                                <th class="px-3 py-2">
                                                    Interval
                                                </th>
                                                <th class="px-3 py-2">
                                                    PresentFla
                                                </th>
                                                <th class="px-3 py-2">
                                                    AllowsTea
                                                </th>
                                                <th class="px-3 py-2">
                                                    PresentMode
                                                </th>
                                            </tr>
                                        </thead>
                                        <tbody class="VK_theme_tbody">
                                            <tr>
                                                <td>
                                                    1
                                                </td>
                                                <td>
                                                    0
                                                </td>
                                                <td>
                                                    0
                                                </td>
                                                <td>
                                                    Hardware Composed: Independent Flip
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>
                                                    1
                                                </td>
                                                <td>
                                                    0
                                                </td>
                                                <td>
                                                    0
                                                </td>
                                                <td>
                                                    Hardware Composed: Independent Flip
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>
                                                    1
                                                </td>
                                                <td>
                                                    0
                                                </td>
                                                <td>
                                                    0
                                                </td>
                                                <td>
                                                    HArdware Composed: Independent Flip
                                                </td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <ul>
                                        <li>
                                            For DirectX 11 and 12, it is recommended to use the flip model, if
                                            available.
                                        </li>
                                        <li>
                                            For Windows 8, FLIP_SEQUENTIAL is recommended.
                                        </li>
                                        <li>
                                            For Windows 10/11, FLIP_DISCARD is recommended.
                                        </li>
                                    </ul>
                                </div>
                            </section>
                            <section class="mt-4" id="VK_MultiQueue_Support_Recommendations">
                                <h3 class="VK_n22">
                                    Multi-Queue Support Recommendations
                                </h3>
                                <p>
                                    Xe-HPG supports the use of queues, which can concurrently have both 3D and compute
                                    workloads resident in the threads of each Xe-core. There is also a copy engine
                                    present for parallel copies. When sharing resources across queues, consider the
                                    following recommendations:
                                </p>
                                <ul>
                                    <li>
                                        Always profile code to see if using dual-queue support for asynchronous compute
                                        will provide a benefit.
                                    </li>
                                    <li>
                                        Use COMMON state transitions when possible.
                                    </li>
                                    <li>
                                        Use a dedicated copy queue to fetch resources when it makes sense.
                                    </li>
                                    <li>
                                        Vulkan: Use vkGetPhysicalDeviceQueueFamilyProperties to enumerate queues to see
                                        what kind of queues there are, and how many can be created per family.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_CPU_Performance_Considerations">
                                <h3 class="VK_n22">
                                    CPU Performance Considerations
                                </h3>
                                <ul>
                                    <li>
                                        The Intel DirectX and Vulkan drivers utilize threading to perform work
                                        parallelization. Fully subscribing all available CPU hardware threads with
                                        application work can result in starvation of these helper threads and
                                        significantly reduce performance. Query the available hardware threads on the
                                        system your application runs on, and pay attention to thread oversubscription.
                                    </li>
                                    <li>
                                        The DirectX 12 driver relies heavily on
                                        <a href="" class="Vk_text_underline_dots VK_a">
                                            background shader optimizations
                                        </a>
                                        Do NOT disable this thread with DISABLE_BACKGROUND_WORK or
                                        DISABLE_PROFILING_BY_SYSTEM in ID3D12Device6::SetBackgroundProcessingMode(). If
                                        you do, it will significantly increase loading times, and can significantly
                                        reduce GPU performance, because these optimizations can no longer be performed.
                                        Also, ensure you leave at least one CPU hardware thread available to perform
                                        this work; do not fully subscribe every available hardware thread on the CPU
                                        with application work.
                                    </li>
                                </ul>
                            </section>
                            <section class="mt-4" id="VK_Additional_Resources">
                                <h3 class="VK_side_heading fw-light">
                                    Additional Resources
                                </h3>
                            </section>
                            <section class="mt-4" id="VK_Software_and_Samples">
                                <h3 class="VK_side_heading">
                                    Software and Samples
                                </h3>
                                <p>
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        GitHub Intel Repository
                                    </a>
                                </p>
                                <p>
                                    <a href="/VK_developers/VK_developer_game_development.html"
                                        class="Vk_text_underline_dots VK_a">
                                        Intel® Game Dev
                                    </a>
                                </p>
                                <p>
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        GPU Detect Sample
                                    </a>
                                </p>
                                <p>
                                    <a href="/VK_developers/VK_Tuning_Guides_Performance_Analysis_Papers.html"
                                        class="Vk_text_underline_dots VK_a">
                                        Fast ISPC Texture Compressor Sample
                                    </a>
                                </p>
                            </section>
                            <section class="mt-4" id="VK_Tools">
                                <h3 class="VK_side_heading">
                                    Tools
                                </h3>
                                <p>
                                    <a href="/dhruvin_developer-tools/Development-Tools/ds_Graphics-Performance-Analyzers.html"
                                        class="Vk_text_underline_dots VK_a">
                                        Intel GPA
                                    </a>
                                </p>
                                <p>
                                    <a href="/VK_developers/VK_vtune_profiler.html" class="Vk_text_underline_dots VK_a">
                                        Intel VTune Profiler
                                    </a>
                                </p>
                            </section>
                            <section class="mt-4" id="VK_Graphics_API">
                                <h3 class="VK_side_heading">
                                    Graphics API
                                </h3>
                                <p>
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Direct3D* Website
                                    </a>
                                    - DirectX 12 and other DirectX resources
                                </p>
                                <p>
                                    <a href="" class="Vk_text_underline_dots VK_a">
                                        Vulkan
                                    </a>
                                    - Khronos* site with additional resources
                                </p>
                            </section>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="py-5">
            <div class="VK_cont">
                <div class="row m-0">
                    <div class="col">
                        <p>
                            Product and Performance Information
                        </p>
                        <p class="VK_font12">
                            1Performance varies by use, configuration and other factors. Learn more at
                            <a href="" class="Vk_text_underline_dots VK_a">
                                www.Intel.com/PerformanceIndex.
                            </a>
                        </p>
                    </div>
                </div>
            </div>
        </section>


        <!-- footer -->
        <footer>
            <div id="footer"></div>
        </footer>

    </main>

    <!---------------- Javascript Files ---------------->

    <script>
        // navbar include
        fetch('/y_index/y_navbar.html')
            .then(response => response.text())
            .then(data => {
                document.getElementById('navbar').innerHTML = data;
            });
        // footer include 
        fetch('/y_index/y_footer.html')
            .then(response => response.text())
            .then(data => {
                document.getElementById('footer').innerHTML = data;
            });
    </script>

    <!-- jquery -->
    <script src="/js/jquery-3.7.1.js"></script>


    <!-- bootstrap js file -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>

    <!-- costom js file -->
    <script src="/js/vivek.js"></script>

    <!-- all min -->
    <!-- <script src="/js/all.min.js"></script> -->

</body>

</html>